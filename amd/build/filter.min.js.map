{"version":3,"file":"filter.min.js","sources":["../src/filter.js"],"sourcesContent":["\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n/**\n * @module    local_wunderbyte_table\n * @copyright  Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getSearchInput} from 'local_wunderbyte_table/search';\nimport {getSortSelection} from 'local_wunderbyte_table/sort';\n\nimport {callLoadData, SELECTORS} from 'local_wunderbyte_table/init';\nimport Templates from 'core/templates';\nimport {debounce} from 'core/utils';\n\n// These variables are specific to the filter.\nvar checked = {};\n\n/**\n * Initialize Checkboxes.\n * @param {string} selector\n * @param {string} idstring\n * @param {string} encodedtable\n */\nexport function initializeCheckboxes(selector, idstring, encodedtable) {\n\n  const filterContainer = document.querySelector(selector + SELECTORS.FILTER);\n\n  if (!filterContainer || filterContainer.dataset.initialized) {\n    return;\n  }\n  const selects = filterContainer.querySelectorAll(\"select[id^='filteroperationselect']\");\n  const filterElements = filterContainer.querySelectorAll(\"input[class^='filterelement']\");\n  const hierarchcheckboxes = filterContainer.querySelectorAll('.hierarchycategory-checkbox');\n\n  if (!filterElements) {\n    return;\n  }\n\n  // We create the key for the checked items of this table.\n  if (!checked.hasOwnProperty(idstring)) {\n    checked[idstring] = {};\n  }\n\n  // We run through all the filter elements and make sure that we store the state we received from php.\n  filterElements.forEach(element => {\n    getChecked(element.name, selector, idstring);\n  });\n\n  applyChangelistener(filterElements, selector, idstring, encodedtable);\n  applyChangelistener(selects, selector, idstring, encodedtable);\n\n  if (hierarchcheckboxes) {\n    handleHierarchyCategoryCheckbox(hierarchcheckboxes, filterElements, selector, idstring, encodedtable);\n  }\n\n  filterContainer.dataset.initialized = true;\n}\n\n\n/**\n * Initialize Prefixsearch.\n * @param {string} selector\n * @param {string} idstring\n * @param {string} encodedtable\n */\nexport function initializeSearchInputListener(selector, idstring, encodedtable) {\n  const container = document.querySelector(selector);\n  if (!container) {\n    return;\n  }\n\n  // Select the specific prefix search input by ID\n  const searchInput = container.querySelector(`#prefixsearch${idstring}`);\n\n  if (searchInput) {\n        searchInput.addEventListener('input', debounce(() => {\n         const searchValue = searchInput.value;\n          checked[idstring]['titleprefix'] = searchValue;\n          triggerReload(idstring, encodedtable);\n    }, 300));\n  }\n}\n\n/**\n * Apply change listener to list of nodes.\n * @param {*} nodelist\n * @param {*} selector\n * @param {*} idstring\n * @param {*} encodedtable\n */\nfunction applyChangelistener(nodelist, selector, idstring, encodedtable) {\n  if (nodelist) {\n    nodelist.forEach(el => {\n\n      if (!el.dataset.idstring) {\n        el.dataset.idstring = idstring;\n      } else {\n        el.dataset.idstring2 = idstring;\n      }\n      [\"change\", \"keyup\"].forEach(event => {\n        el.addEventListener(event, (e) => toggleFilterelement(e, selector, idstring, encodedtable));\n      });\n    });\n  }\n}\n/**\n * Init for button to reset all filter and searchparams.\n * @param {*} selector\n * @param {*} idstring\n * @param {*} encodedtable\n */\nexport function initializeResetFilterButton(selector, idstring, encodedtable) {\n  const container = document.querySelector(selector);\n  if (!container) {\n    return;\n  }\n  let button = container.querySelector(\".reset-filter-button\");\n\n  // eslint-disable-next-line no-console\n  console.log(button);\n\n  if (!button) {\n    return;\n  }\n  button.addEventListener('click', () => {\n\n    if (!container) {\n      return;\n    }\n\n    const componentscontainer = container.querySelector(\".wunderbyte_table_components\");\n\n    if (!componentscontainer) {\n      return;\n    }\n\n    componentscontainer.remove();\n\n    resetCheckedObject(idstring);\n\n    const sort = getSortSelection(idstring);\n    callLoadData(idstring,\n      encodedtable,\n      0, // Pagenumber is always set to 0.\n      null,\n      sort,\n      null,\n      null,\n      null,\n      \"\",\n      \"\");\n  });\n}\n/**\n * Eventhandler\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n * @param {*} encodedtable\n */\nexport function toggleFilterelement(e, selector, idstring, encodedtable) {\n\n  e.stopPropagation();\n  e.preventDefault();\n\n  setTimeout(() => {\n    // Check if Checkbox corresponds to datepicker\n    if (e.target.type === 'checkbox') {\n            handleParentCheckbox(e.target);\n    }\n    if (e.target.dataset.dateelement == 'dateelement') {\n      getDates(e, selector, idstring);\n    } else if (e.target.dataset.intrangeelement && e.target.dataset.intrangeelement.includes('intrangeelement')) {\n      getIntRange(e, selector, idstring);\n      // eslint-disable-next-line no-console\n      console.log(\"intrangeelement\");\n    } else {\n      getChecked(e.target.name, selector, idstring);\n    }\n\n    triggerReload(idstring, encodedtable);\n  }, 400);\n}\n\n/**\n * Handles the behavior of parent checkboxes in a hierarchical structure.\n * When a child checkbox is checked/unchecked, this function updates the state\n * of the parent checkbox accordingly. The parent checkbox will be checked if\n * all children are checked, and unchecked if any child is unchecked.\n *\n * @param {HTMLInputElement} checkbox - The checkbox element that triggered the event\n */\nfunction handleParentCheckbox(checkbox) {\n    const wrapper = checkbox.closest('ul.hierarchy');\n    if (!wrapper) {\n      return;\n    }\n    const spanElement = wrapper.querySelector('.d-flex');\n    const parentCheckbox = spanElement.querySelector('.hierarchycategory-checkbox');\n    if (!parentCheckbox) {\n      return;\n    }\n    const siblingCheckboxes = wrapper.querySelectorAll('.hierarchychild-checkbox');\n    const allChecked = Array.from(siblingCheckboxes).every(cb => cb.checked);\n\n    if (allChecked) {\n        parentCheckbox.checked = true;\n    } else if (Array.from(siblingCheckboxes).some(cb => !cb.checked)) {\n        parentCheckbox.checked = false;\n    }\n}\n\n/**\n * Trigger the reload with filter, search, sort.\n *\n * @param {*} idstring\n * @param {*} encodedtable\n *\n */\nfunction triggerReload(idstring, encodedtable) {\n      // Reload the filtered elements via ajax.\n    const filterobjects = getFilterObjects(idstring);\n    const searchstring = getSearchInput(idstring);\n    const sort = getSortSelection(idstring);\n\n    // The filter reloads data from the Server.\n    // Because of pages and infinite scroll we don't have the data to do without.\n    callLoadData(idstring,\n      encodedtable,\n      0, // Pagenumber is always set to 0.\n      null,\n      sort,\n      null,\n      null,\n      null,\n      filterobjects,\n      searchstring);\n}\n\n/**\n * Check if the checkbox of the filterparam is checked and if so write values from date- and timepicker into checked variable.\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n */\nexport function getDates(e, selector, idstring) {\n\n  let name = e.target.dataset.columnname;\n  let filtercontainer = e.target.closest(\".datepickerform\");\n  let filtername = e.target.dataset.filtername;\n  let filtercheckbox = filtercontainer.querySelector('input[type=\"checkbox\"][id^=\"' + filtername + '\"][name=\"' + name + '\"]');\n\n  let dates = {};\n  if (filtercheckbox.dataset.timespan === \"true\") {\n    compareDateValues(e, filtercontainer);\n  }\n  if (filtercheckbox.checked) {\n    // Check if we have a timespan filter or a single one.\n    if (filtercheckbox.dataset.timespan === \"true\") {\n      setTimespanFilter(filtercontainer, filtername, idstring, name);\n    } else {\n      dates[String(filtercheckbox.dataset.operator)] = getDateAndTimePickerDataAsUnix(filtercontainer, \"datefilter\") / 1000;\n      // Check if key is set in array, otherwise set new key.\n      if (name && filtername) {\n        if (!checked[idstring][name]) {\n          checked[idstring][name] = {};\n        }\n        checked[idstring][name][filtername] = dates;\n      }\n      unsetEmptyFieldsInCheckedObject(name, filtername, idstring);\n    }\n  } else { // If checkbox of filter is unchecked: unset values in checked object.\n    resetCheckedObject(idstring, name, filtername);\n    unsetEmptyFieldsInCheckedObject(name, null, idstring);\n    // Vorher noch ein if exists etc.\n    Object.keys(checked[idstring]).forEach(function(key) {\n      Object.keys(checked[idstring][key]).forEach(function(okey) {\n        if (okey == filtername) {\n          resetCheckedObject(idstring, key, filtername);\n          unsetEmptyFieldsInCheckedObject(key, null, idstring);\n        }\n      }\n      );\n    }\n    );\n  }\n  updateFilterCounter(name, selector, idstring);\n}\n\n/**\n * Check if date and time value set in first timepicker is before second timepicker.\n * @param {*} e // The element that triggerd the change.\n * @param {*} filtercontainer\n */\nfunction compareDateValues(e, filtercontainer) {\n  let startdate = getDateAndTimePickerDataAsUnix(filtercontainer, \"startdate\");\n  let enddate = getDateAndTimePickerDataAsUnix(filtercontainer, \"enddate\");\n\n  // We make sure the entered enddate is after 2020, to avoid triggering change while date setting is not finished yet.\n  if ((enddate / 1000 > 1577836800) && (startdate > enddate)) {\n    // Apply change.\n    setDateAndTimePickerDataFromUnix(filtercontainer, 'startdate', enddate);\n  }\n}\n\n/**\n * Checking Date and Timepicker for corresponding element and returning Unix Code.\n * @param {*} filtercontainer\n * @param {string} id // Id of the date- and timepicker, the value should be applied to.\n * @param {integer} timestamp\n */\nexport function setDateAndTimePickerDataFromUnix(filtercontainer, id = '', timestamp) {\n\n  let dateobject = new Date(timestamp);\n\n  let datepicker = filtercontainer.querySelector('input[type=\"date\"][id*=\"' + id + '\"]');\n  datepicker.value = dateobject.toISOString().split('T')[0];\n\n  let timepicker = filtercontainer.querySelector('input[type=\"time\"][id*=\"' + id + '\"]');\n  timepicker.value = dateobject.toLocaleTimeString().slice(0, 5);\n}\n\n/**\n * Applying a timespan filter.\n * @param {*} filtercontainer\n * @param {string} filtername\n * @param {string} idstring\n * @param {string} name\n */\nfunction setTimespanFilter(filtercontainer, filtername, idstring, name) {\n  // Selector defined the operators.\n  let select = filtercontainer.querySelector('select[id^=\"filteroperationselect\"][name=\"' + name + '\"]');\n  let operator = select.value;\n\n  // First Column to apply the filter to\n  let startdatepicker = filtercontainer.querySelector('input[id^=\"startdate\"]');\n  let firstcolumn = startdatepicker.dataset.applytocolumn;\n  let firstoperator = \"\";\n  let additionalFirstColumnValues = {};\n  let valuefirstcolumn = getDateAndTimePickerDataAsUnix(filtercontainer, \"startdate\") / 1000;\n\n  // Second Column to apply the filter to\n  let enddatepicker = filtercontainer.querySelector('input[id^=\"enddate\"]');\n  let secondcolumn = enddatepicker.dataset.applytocolumn;\n  let secondoperator = \"\";\n  let additionalSecondColumnValues = {};\n  let valuesecondcolumn = getDateAndTimePickerDataAsUnix(filtercontainer, \"enddate\") / 1000;\n\n  if (!Number.isInteger(valuefirstcolumn) || !Number.isInteger(valuefirstcolumn)) {\n    return;\n  }\n\n  // Unset the values of the span filter in checked object.\n  resetCheckedObject(idstring, firstcolumn, filtername);\n  resetCheckedObject(idstring, secondcolumn, filtername);\n\n  switch (operator) {\n    case \"within\":\n      firstoperator = \">=\";\n      secondoperator = \"<=\";\n      break;\n    case \"overlapboth\":\n      firstoperator = \"<=\";\n      secondoperator = \">=\";\n      break;\n    case \"overlapstart\":\n      firstoperator = \"<=\";\n      additionalSecondColumnValues[\">=\"] = valuefirstcolumn;\n      secondoperator = \"<=\";\n      break;\n    case \"overlapend\":\n      firstoperator = \">=\";\n      secondoperator = \">=\";\n      additionalFirstColumnValues[\"<=\"] = valuesecondcolumn;\n      break;\n    case \"before\":\n      firstoperator = \"<\";\n      additionalSecondColumnValues[\"<=\"] = valuefirstcolumn;\n      secondoperator = \"<\";\n      break;\n    case \"after\":\n      secondoperator = \">=\";\n      additionalFirstColumnValues[\">=\"] = valuesecondcolumn;\n      firstoperator = \">\";\n      break;\n    case \"flexoverlap\":\n      firstoperator = \"fo\";\n      secondoperator = \"fo\";\n      break;\n    default:\n      break;\n  }\n  if (!secondcolumn) {\n    secondcolumn = firstcolumn;\n  }\n  applySpanfilter(firstcolumn, valuefirstcolumn, filtername, firstoperator, additionalFirstColumnValues, idstring);\n  applySpanfilter(secondcolumn, valuesecondcolumn, filtername, secondoperator, additionalSecondColumnValues, idstring);\n\n  // Unsetting the timespan filter if empty\n  if (firstcolumn && filtername) {\n    unsetEmptyFieldsInCheckedObject(firstcolumn, filtername, idstring);\n  }\n  if (secondcolumn && filtername) {\n    unsetEmptyFieldsInCheckedObject(secondcolumn, filtername, idstring);\n  }\n}\n\n/**\n *  Check if filter object already exisits and unset values.\n * @param {string} idstring\n * @param {string} column\n * @param {string} filtername\n */\nfunction resetCheckedObject(idstring, column = '', filtername = '') {\n\n  // If no column is specified, we reset all the filters.\n  if (column.length === 0) {\n\n    Object.keys(checked[idstring]).forEach(col => {\n      checked[idstring][col] = [];\n    });\n  } else {\n    if (checked[idstring].hasOwnProperty(column)) {\n      if (checked[idstring][column].hasOwnProperty(filtername)) {\n        delete checked[idstring][column][filtername];\n      }\n      if (checked[idstring][column].hasOwnProperty(filtername + 'a')) {\n        delete checked[idstring][column][filtername + 'a'];\n      }\n      if (\n        Array.isArray(checked[idstring][column]) &&\n        checked[idstring][column].length === 1 &&\n        checked[idstring][column][0] === 'datecheckbox'\n      ) {\n        delete checked[idstring][column];\n      }\n    }\n  }\n}\n\n/**\n *  Check if object already exisits and set values.\n * @param {string} column\n * @param {*} value\n * @param {string} filtername\n * @param {string} operator\n * @param {*} additionalvaluesObject\n * @param {string} idstring\n */\nfunction applySpanfilter(column, value, filtername, operator, additionalvaluesObject, idstring) {\n  if (operator.length >= 1) {\n    if (column && filtername) {\n      if (!checked[idstring][column]) {\n        checked[idstring][column] = {};\n      }\n      if (!checked[idstring][column][filtername]) {\n        checked[idstring][column][filtername] = {};\n      }\n      checked[idstring][column][filtername][operator] = value;\n      if (Object.keys(additionalvaluesObject).length > 0) {\n        checked[idstring][column][filtername + 'a'] = additionalvaluesObject;\n      }\n    }\n  }\n}\n\n/**\n * Unsetting empty keys in checked object. If a filter param was created and deleted later on we will need this.\n * @param {*} key1\n * @param {*} key2\n * @param {string} idstring\n */\nfunction unsetEmptyFieldsInCheckedObject(key1, key2, idstring) {\n  if (checked[idstring][key1]) {\n    if (checked[idstring][key1][key2]) {\n      if (Object.keys(checked[idstring][key1][key2]).length < 1) {\n        delete checked[idstring][key1][key2];\n      }\n    }\n  }\n\n  if (checked[idstring][key1]) {\n    if (Object.keys(checked[idstring][key1]).length < 1) {\n      delete checked[idstring][key1];\n    }\n  }\n}\n\n/**\n * Checking Date and Timepicker for corresponding element and returning Unix Code.\n * @param {*} filtercontainer\n * @param {string} id\n * @returns {string}\n */\nexport function getDateAndTimePickerDataAsUnix(filtercontainer, id = '') {\n\n  let datepicker = filtercontainer.querySelector('input[type=\"date\"][id*=\"' + id + '\"]');\n  let date = datepicker.value;\n\n  let timepicker = filtercontainer.querySelector('input[type=\"time\"][id*=\"' + id + '\"]');\n  let time = timepicker.value;\n\n  let unixTimestamp = Date.parse(date + ' ' + time);\n  let tenDigitTimestamp = unixTimestamp;\n\n  return tenDigitTimestamp;\n}\n\n/**\n * Generating and displaying filterparams in URL.\n * @param {string} filterobjects\n * @param {string} searchstring\n * @param {string} sort\n * @param {*} dir\n */\nexport function updateUrlWithFilterSearchSort(filterobjects, searchstring, sort, dir) {\n\n  const url = new URL(window.location.href);\n\n  let params = url.searchParams;\n\n  // We don't actually want to delete all url params, only those we don't use for searching.\n  params.delete('wbtfilter');\n  params.delete('wbtsearch');\n  params.delete('tsort');\n  params.delete('tdir');\n\n  window.history.replaceState(null, '', url);\n\n  if (filterobjects) {\n    url.searchParams.append('wbtfilter', filterobjects);\n  }\n  if (searchstring !== \"\" &&\n    searchstring !== null) {\n    url.searchParams.append('wbtsearch', searchstring);\n  }\n  if (sort !== \"\" &&\n    sort !== null) {\n    url.searchParams.append('tsort', sort);\n  }\n  if (dir !== null &&\n    dir > 0) {\n    url.searchParams.append('tdir', dir);\n  }\n\n  window.history.pushState(null, null, url.toString());\n}\n\n/**\n * Generating and displaying filterparams in URL.\n * @param {string} idstring\n * @param {string} filterobjects\n * @param {string} searchstring\n * @param {string} sort\n * @param {*} dir\n */\nexport function updateDownloadUrlWithFilterSearchSort(idstring, filterobjects, searchstring, sort, dir) {\n\n  // The container will hold wunderbyteTableClass, wunderbyteTableFilter, wunderbyteTableSearch classes.\n  let container = document.querySelector(\".wunderbyte_table_container_\" + idstring);\n  if (!container) {\n    return;\n  }\n\n  let url = '';\n  let formelement = null;\n  try {\n    formelement = container.querySelector('form.wb-table-download-buttons');\n    url = new URL(formelement.getAttribute('action'));\n  } catch (e) {\n\n    // eslint-disable-next-line no-console\n    console.log(e);\n    return;\n  }\n\n  let params = url.searchParams;\n\n  // We don't actually want to delete all url params, only those we don't use for searching.\n  params.delete('wbtfilter');\n  params.delete('wbtsearch');\n  params.delete('tsort');\n  params.delete('tdir');\n\n  if (filterobjects) {\n    url.searchParams.append('wbtfilter', filterobjects);\n  }\n  if (searchstring !== \"\" &&\n    searchstring !== null) {\n    url.searchParams.append('wbtsearch', searchstring);\n  }\n  if (sort !== \"\" &&\n    sort !== null) {\n    url.searchParams.append('tsort', sort);\n  }\n  if (dir !== null &&\n    dir > 0) {\n    url.searchParams.append('tdir', dir);\n  }\n\n  formelement.action = url.toString();\n}\n\n/**\n * Gets an array of checkboxes for every table by idstring.\n * @param {*} name\n * @param {*} selector\n * @param {*} idstring\n */\nexport function getChecked(name, selector, idstring) {\n\n  // We might have more than one Table, therefore we first have to get all tables.\n  const wbTable = document.querySelector(selector);\n\n  checked[idstring][name] = Array.from(\n    wbTable.querySelectorAll(\"input[name=\" + name + \"]\")\n  ).filter(function(el) {\n    return el.checked;\n  }).map(function(el) {\n    return el.value;\n  });\n\n  // If there are no checked boxes, we unset the key alltogether.\n  if (checked[idstring][name].length < 1) {\n    delete checked[idstring][name];\n  }\n\n  updateFilterCounter(name, selector, idstring);\n}\n\n/**\n * Gets the values of the checked intrange filter.\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n */\nexport function getIntRange(e, selector, idstring) {\n\n  // We might have more than one Table, therefore we first have to get all tables.\n  let filtercontainer = e.target.closest(\".intrangeform\");\n\n  let from = filtercontainer.querySelector('input[id*=\"intrangefilter_intrange-start\"]');\n  let fromvalue = from.value;\n  let to = filtercontainer.querySelector('input[id*=\"intrangefilter_intrange-end\"]');\n  let tovalue = to.value;\n  let colname = e.target.dataset.columnname;\n\n  // Add the alert if not all entries are ints (or empty).\n  const isInt = (str) => (!isNaN(parseInt(str)) && isFinite(str)) || (str.trim() === '') || (str === null);\n\n  const alertelement = filtercontainer.querySelector('div[id*=\"intrangefilter_alert\"]');\n  if (!isInt(fromvalue)\n    || !isInt(tovalue)) {\n\n    alertelement.removeAttribute('hidden');\n  } else {\n    alertelement.setAttribute('hidden', 'true');\n\n    // Stripping leading zeros.\n    fromvalue = parseInt(fromvalue, 10);\n    fromvalue = fromvalue.toString();\n    tovalue = parseInt(tovalue, 10);\n    tovalue = tovalue.toString();\n  }\n\n  if (fromvalue.length > 0 || tovalue.length > 0) {\n    checked[idstring][colname] = fromvalue + \",\" + tovalue;\n  }\n\n  // If there are no checked boxes, unset the key when the checkbox is unchecked.\n  if (!filtercontainer.querySelector('input[data-intrangeelement=\"intrangeelement-checkbox\"]').checked) {\n    delete checked[idstring][colname];\n  }\n  updateFilterCounter(colname, selector, idstring);\n}\n\n/**\n * Returns json of active filters as json.\n * @param {*} idstring\n * @returns {string}\n */\nexport function getFilterObjects(idstring) {\n\n  if (!(idstring in checked)) {\n    return '';\n  }\n\n  let hasvalues = false;\n\n  for (const [, value] of Object.entries(checked[idstring])) {\n\n    if (value.length > 0 || Object.keys(value).length > 0) {\n      hasvalues = true;\n    }\n  }\n\n  if (!hasvalues) {\n    return '';\n  }\n  return JSON.stringify(checked[idstring]);\n}\n\n/**\n * Render the checkboxes for the filer.\n * @param {string} filterjson\n * @param {string} idstring\n * @param {string} encodedtable\n */\nexport const renderFilter = (filterjson, idstring, encodedtable) => {\n\n  // We render the filter only once, so if we find it already, we don't render it.\n\n  const selector = SELECTORS.CONTAINER + idstring;\n  const container = document.querySelector(selector);\n  const filtercontainer = container.querySelector(SELECTORS.FILTER);\n\n  if (filtercontainer) {\n    return;\n  }\n\n  Templates.renderForPromise('local_wunderbyte_table/filter', filterjson).then(({html}) => {\n\n    container.insertAdjacentHTML('afterbegin', html);\n    initializeCheckboxes(selector, idstring, encodedtable);\n    return;\n  }).catch(e => {\n    // eslint-disable-next-line no-console\n    console.log(e);\n  });\n};\n\n/**\n * Update Filter counter.\n *\n * @param {*} name\n * @param {*} selector\n * @param {*} idstring\n *\n *\n */\nfunction updateFilterCounter(name, selector, idstring) {\n\n  const wbTable = document.querySelector(selector);\n\n  let counter = checked[idstring][name] ? checked[idstring][name].length : 0;\n  if ((counter > 0 && (typeof checked[idstring][name] === 'string') ||\n    (typeof checked[idstring][name] === 'object' && !Array.isArray(checked[idstring][name])))) {\n    // Handle different cases of filters here (datepicker, intrange).\n    // TODO: Find a better marker for difference of filters.\n    counter = 1;\n  }\n\n  const labelElement = wbTable.querySelector('[data-ident=' + name + '] span.filtercounter');\n\n  if (labelElement) {\n\n    if (counter > 0) {\n      labelElement.classList.remove('hidden');\n    } else {\n      labelElement.classList.add('hidden');\n    }\n    labelElement.textContent = counter;\n  }\n\n  const totalfiltercounter = checked[idstring] ? Object.keys(checked[idstring]).length : 0;\n  const resetElement = wbTable.querySelector('.reset-filter-button');\n\n  if (resetElement) {\n    if (totalfiltercounter > 0) {\n      resetElement.classList.remove('hidden');\n    } else {\n      resetElement.classList.add('hidden');\n    }\n  }\n}\n\n/**\n * Attach a click listener for these checkboxes to check all boxes in category.\n *\n * @param {*} parentCheckboxes\n * @param {*} filterElements\n * @param {*} selector\n * @param {*} idstring\n * @param {*} encodedtable\n *\n */\nfunction handleHierarchyCategoryCheckbox(parentCheckboxes, filterElements, selector, idstring, encodedtable) {\n    parentCheckboxes.forEach(parentCheckbox => {\n      parentCheckbox.addEventListener('click', function() {\n            // Get the closest parent <ul> element\n            const wrapper = parentCheckbox.closest('ul');\n\n            // Find all child checkboxes inside this <ul>\n            const childCheckboxes = wrapper.querySelectorAll('.form-check-input');\n\n            childCheckboxes.forEach(childCheckbox => {\n                // Only click if current state doesn't match parent\n                if (childCheckbox.checked !== parentCheckbox.checked) {\n                    childCheckbox.checked = parentCheckbox.checked; // Triggers associated JS\n                }\n            });\n            filterElements.forEach(element => {\n              getChecked(element.name, selector, idstring);\n            });\n            triggerReload(idstring, encodedtable);\n        });\n    });\n}"],"names":["selector","idstring","encodedtable","container","document","querySelector","button","console","log","addEventListener","componentscontainer","remove","resetCheckedObject","sort","searchInput","searchValue","value","checked","triggerReload","filterobjects","searchstring","dir","url","formelement","URL","getAttribute","e","params","searchParams","delete","append","action","toString","window","location","href","history","replaceState","pushState","initializeCheckboxes","filterContainer","SELECTORS","FILTER","dataset","initialized","selects","querySelectorAll","filterElements","hierarchcheckboxes","hasOwnProperty","forEach","element","getChecked","name","applyChangelistener","parentCheckboxes","parentCheckbox","closest","childCheckbox","handleHierarchyCategoryCheckbox","nodelist","el","idstring2","event","toggleFilterelement","stopPropagation","preventDefault","setTimeout","target","type","checkbox","wrapper","siblingCheckboxes","Array","from","every","cb","some","handleParentCheckbox","dateelement","getDates","intrangeelement","includes","getIntRange","getFilterObjects","columnname","filtercontainer","filtername","filtercheckbox","dates","timespan","startdate","getDateAndTimePickerDataAsUnix","enddate","setDateAndTimePickerDataFromUnix","compareDateValues","operator","firstcolumn","applytocolumn","firstoperator","additionalFirstColumnValues","valuefirstcolumn","secondcolumn","secondoperator","additionalSecondColumnValues","valuesecondcolumn","Number","isInteger","applySpanfilter","unsetEmptyFieldsInCheckedObject","setTimespanFilter","String","Object","keys","key","okey","updateFilterCounter","id","timestamp","dateobject","Date","datepicker","toISOString","split","timepicker","toLocaleTimeString","slice","column","length","col","isArray","additionalvaluesObject","key1","key2","date","time","unixTimestamp","parse","wbTable","filter","map","fromvalue","tovalue","colname","isInt","str","isNaN","parseInt","isFinite","trim","alertelement","setAttribute","removeAttribute","hasvalues","entries","JSON","stringify","counter","labelElement","classList","add","textContent","totalfiltercounter","resetElement","filterjson","CONTAINER","renderForPromise","then","_ref","html","insertAdjacentHTML","catch"],"mappings":";;;;;2WA6H4CA,SAAUC,SAAUC,oBACxDC,UAAYC,SAASC,cAAcL,cACpCG,qBAGDG,OAASH,UAAUE,cAAc,2BAGrCE,QAAQC,IAAIF,SAEPA,cAGLA,OAAOG,iBAAiB,SAAS,SAE1BN,uBAICO,oBAAsBP,UAAUE,cAAc,oCAE/CK,2BAILA,oBAAoBC,SAEpBC,mBAAmBX,gBAEbY,MAAO,0BAAiBZ,iCACjBA,SACXC,aACA,EACA,KACAW,KACA,KACA,KACA,KACA,GACA,wDArFwCb,SAAUC,SAAUC,oBAC1DC,UAAYC,SAASC,cAAcL,cACpCG,uBAKCW,YAAcX,UAAUE,cAAe,gBAAeJ,YAExDa,aACEA,YAAYL,iBAAiB,SAAS,oBAAS,WACxCM,YAAcD,YAAYE,MAC/BC,QAAQhB,UAAR,YAAmCc,YACnCG,cAAcjB,SAAUC,gBAC3B,wNA6d+CD,SAAUkB,cAAeC,aAAcP,KAAMQ,SAG7FlB,UAAYC,SAASC,cAAc,+BAAiCJ,cACnEE,qBAIDmB,IAAM,GACNC,YAAc,SAEhBA,YAAcpB,UAAUE,cAAc,kCACtCiB,IAAM,IAAIE,IAAID,YAAYE,aAAa,WACvC,MAAOC,eAGPnB,QAAQC,IAAIkB,OAIVC,OAASL,IAAIM,aAGjBD,OAAOE,OAAO,aACdF,OAAOE,OAAO,aACdF,OAAOE,OAAO,SACdF,OAAOE,OAAO,QAEVV,eACFG,IAAIM,aAAaE,OAAO,YAAaX,eAElB,KAAjBC,cACe,OAAjBA,cACAE,IAAIM,aAAaE,OAAO,YAAaV,cAE1B,KAATP,MACO,OAATA,MACAS,IAAIM,aAAaE,OAAO,QAASjB,MAEvB,OAARQ,KACFA,IAAM,GACNC,IAAIM,aAAaE,OAAO,OAAQT,KAGlCE,YAAYQ,OAAST,IAAIU,4DArFmBb,cAAeC,aAAcP,KAAMQ,WAEzEC,IAAM,IAAIE,IAAIS,OAAOC,SAASC,UAEhCR,OAASL,IAAIM,aAGjBD,OAAOE,OAAO,aACdF,OAAOE,OAAO,aACdF,OAAOE,OAAO,SACdF,OAAOE,OAAO,QAEdI,OAAOG,QAAQC,aAAa,KAAM,GAAIf,KAElCH,eACFG,IAAIM,aAAaE,OAAO,YAAaX,eAElB,KAAjBC,cACe,OAAjBA,cACAE,IAAIM,aAAaE,OAAO,YAAaV,cAE1B,KAATP,MACO,OAATA,MACAS,IAAIM,aAAaE,OAAO,QAASjB,MAEvB,OAARQ,KACFA,IAAM,GACNC,IAAIM,aAAaE,OAAO,OAAQT,KAGlCY,OAAOG,QAAQE,UAAU,KAAM,KAAMhB,IAAIU,+EAlhBvCf,QAAU,YAQEsB,qBAAqBvC,SAAUC,SAAUC,oBAEjDsC,gBAAkBpC,SAASC,cAAcL,SAAWyC,gBAAUC,YAE/DF,iBAAmBA,gBAAgBG,QAAQC,yBAG1CC,QAAUL,gBAAgBM,iBAAiB,uCAC3CC,eAAiBP,gBAAgBM,iBAAiB,iCAClDE,mBAAqBR,gBAAgBM,iBAAiB,+BAEvDC,iBAKA9B,QAAQgC,eAAehD,YAC1BgB,QAAQhB,UAAY,IAItB8C,eAAeG,SAAQC,UACrBC,WAAWD,QAAQE,KAAMrD,SAAUC,aAGrCqD,oBAAoBP,eAAgB/C,SAAUC,SAAUC,cACxDoD,oBAAoBT,QAAS7C,SAAUC,SAAUC,cAE7C8C,6BA+tBmCO,iBAAkBR,eAAgB/C,SAAUC,SAAUC,cAC3FqD,iBAAiBL,SAAQM,iBACvBA,eAAe/C,iBAAiB,SAAS,WAEnB+C,eAAeC,QAAQ,MAGPX,iBAAiB,qBAEjCI,SAAQQ,gBAEhBA,cAAczC,UAAYuC,eAAevC,UACzCyC,cAAczC,QAAUuC,eAAevC,YAG/C8B,eAAeG,SAAQC,UACrBC,WAAWD,QAAQE,KAAMrD,SAAUC,aAErCiB,cAAcjB,SAAUC,oBAhvBhCyD,CAAgCX,mBAAoBD,eAAgB/C,SAAUC,SAAUC,cAG1FsC,gBAAgBG,QAAQC,aAAc,YAmC/BU,oBAAoBM,SAAU5D,SAAUC,SAAUC,cACrD0D,UACFA,SAASV,SAAQW,KAEVA,GAAGlB,QAAQ1C,SAGd4D,GAAGlB,QAAQmB,UAAY7D,SAFvB4D,GAAGlB,QAAQ1C,SAAWA,UAIvB,SAAU,SAASiD,SAAQa,QAC1BF,GAAGpD,iBAAiBsD,OAAQrC,GAAMsC,oBAAoBtC,EAAG1B,SAAUC,SAAUC,+BA4DrE8D,oBAAoBtC,EAAG1B,SAAUC,SAAUC,cAEzDwB,EAAEuC,kBACFvC,EAAEwC,iBAEFC,YAAW,KAEa,aAAlBzC,EAAE0C,OAAOC,eAyBaC,gBACpBC,QAAUD,SAASb,QAAQ,oBAC5Bc,qBAICf,eADce,QAAQlE,cAAc,WACPA,cAAc,mCAC5CmD,4BAGCgB,kBAAoBD,QAAQzB,iBAAiB,4BAChC2B,MAAMC,KAAKF,mBAAmBG,OAAMC,IAAMA,GAAG3D,UAG5DuC,eAAevC,SAAU,EAClBwD,MAAMC,KAAKF,mBAAmBK,MAAKD,KAAOA,GAAG3D,YACpDuC,eAAevC,SAAU,GAxCrB6D,CAAqBpD,EAAE0C,QAEK,eAAhC1C,EAAE0C,OAAOzB,QAAQoC,YACnBC,SAAStD,EAAG1B,SAAUC,UACbyB,EAAE0C,OAAOzB,QAAQsC,iBAAmBvD,EAAE0C,OAAOzB,QAAQsC,gBAAgBC,SAAS,oBACvFC,YAAYzD,EAAG1B,SAAUC,UAEzBM,QAAQC,IAAI,oBAEZ4C,WAAW1B,EAAE0C,OAAOf,KAAMrD,SAAUC,UAGtCiB,cAAcjB,SAAUC,gBACvB,cAsCIgB,cAAcjB,SAAUC,oBAEvBiB,cAAgBiE,iBAAiBnF,UACjCmB,cAAe,0BAAenB,UAC9BY,MAAO,0BAAiBZ,iCAIjBA,SACXC,aACA,EACA,KACAW,KACA,KACA,KACA,KACAM,cACAC,uBASU4D,SAAStD,EAAG1B,SAAUC,cAEhCoD,KAAO3B,EAAE0C,OAAOzB,QAAQ0C,WACxBC,gBAAkB5D,EAAE0C,OAAOX,QAAQ,mBACnC8B,WAAa7D,EAAE0C,OAAOzB,QAAQ4C,WAC9BC,eAAiBF,gBAAgBjF,cAAc,+BAAiCkF,WAAa,YAAclC,KAAO,MAElHoC,MAAQ,GAC4B,SAApCD,eAAe7C,QAAQ+C,mBAyCFhE,EAAG4D,qBACxBK,UAAYC,+BAA+BN,gBAAiB,aAC5DO,QAAUD,+BAA+BN,gBAAiB,WAGzDO,QAAU,IAAO,YAAgBF,UAAYE,SAEhDC,iCAAiCR,gBAAiB,YAAaO,SA/C/DE,CAAkBrE,EAAG4D,iBAEnBE,eAAevE,QAEuB,SAApCuE,eAAe7C,QAAQ+C,kBAuEJJ,gBAAiBC,WAAYtF,SAAUoD,UAG5D2C,SADSV,gBAAgBjF,cAAc,6CAA+CgD,KAAO,MAC3ErC,MAIlBiF,YADkBX,gBAAgBjF,cAAc,0BAClBsC,QAAQuD,cACtCC,cAAgB,GAChBC,4BAA8B,GAC9BC,iBAAmBT,+BAA+BN,gBAAiB,aAAe,IAIlFgB,aADgBhB,gBAAgBjF,cAAc,wBACjBsC,QAAQuD,cACrCK,eAAiB,GACjBC,6BAA+B,GAC/BC,kBAAoBb,+BAA+BN,gBAAiB,WAAa,QAEhFoB,OAAOC,UAAUN,oBAAsBK,OAAOC,UAAUN,gCAK7DzF,mBAAmBX,SAAUgG,YAAaV,YAC1C3E,mBAAmBX,SAAUqG,aAAcf,YAEnCS,cACD,SACHG,cAAgB,KAChBI,eAAiB,eAEd,cACHJ,cAAgB,KAChBI,eAAiB,eAEd,eACHJ,cAAgB,KAChBK,6BAA6B,MAAQH,iBACrCE,eAAiB,eAEd,aACHJ,cAAgB,KAChBI,eAAiB,KACjBH,4BAA4B,MAAQK,4BAEjC,SACHN,cAAgB,IAChBK,6BAA6B,MAAQH,iBACrCE,eAAiB,cAEd,QACHA,eAAiB,KACjBH,4BAA4B,MAAQK,kBACpCN,cAAgB,cAEb,cACHA,cAAgB,KAChBI,eAAiB,KAKhBD,eACHA,aAAeL,aAEjBW,gBAAgBX,YAAaI,iBAAkBd,WAAYY,cAAeC,4BAA6BnG,UACvG2G,gBAAgBN,aAAcG,kBAAmBlB,WAAYgB,eAAgBC,6BAA8BvG,UAGvGgG,aAAeV,YACjBsB,gCAAgCZ,YAAaV,WAAYtF,UAEvDqG,cAAgBf,YAClBsB,gCAAgCP,aAAcf,WAAYtF,UAhJxD6G,CAAkBxB,gBAAiBC,WAAYtF,SAAUoD,OAEzDoC,MAAMsB,OAAOvB,eAAe7C,QAAQqD,WAAaJ,+BAA+BN,gBAAiB,cAAgB,IAE7GjC,MAAQkC,aACLtE,QAAQhB,UAAUoD,QACrBpC,QAAQhB,UAAUoD,MAAQ,IAE5BpC,QAAQhB,UAAUoD,MAAMkC,YAAcE,OAExCoB,gCAAgCxD,KAAMkC,WAAYtF,YAGpDW,mBAAmBX,SAAUoD,KAAMkC,YACnCsB,gCAAgCxD,KAAM,KAAMpD,UAE5C+G,OAAOC,KAAKhG,QAAQhB,WAAWiD,SAAQ,SAASgE,KAC9CF,OAAOC,KAAKhG,QAAQhB,UAAUiH,MAAMhE,SAAQ,SAASiE,MAC/CA,MAAQ5B,aACV3E,mBAAmBX,SAAUiH,IAAK3B,YAClCsB,gCAAgCK,IAAK,KAAMjH,kBAOnDmH,oBAAoB/D,KAAMrD,SAAUC,mBAyBtB6F,iCAAiCR,qBAAiB+B,0DAAK,GAAIC,iDAErEC,WAAa,IAAIC,KAAKF,WAEtBG,WAAanC,gBAAgBjF,cAAc,2BAA6BgH,GAAK,MACjFI,WAAWzG,MAAQuG,WAAWG,cAAcC,MAAM,KAAK,OAEnDC,WAAatC,gBAAgBjF,cAAc,2BAA6BgH,GAAK,MACjFO,WAAW5G,MAAQuG,WAAWM,qBAAqBC,MAAM,EAAG,YA8FrDlH,mBAAmBX,cAAU8H,8DAAS,GAAIxC,kEAAa,GAGxC,IAAlBwC,OAAOC,OAEThB,OAAOC,KAAKhG,QAAQhB,WAAWiD,SAAQ+E,MACrChH,QAAQhB,UAAUgI,KAAO,MAGvBhH,QAAQhB,UAAUgD,eAAe8E,UAC/B9G,QAAQhB,UAAU8H,QAAQ9E,eAAesC,oBACpCtE,QAAQhB,UAAU8H,QAAQxC,YAE/BtE,QAAQhB,UAAU8H,QAAQ9E,eAAesC,WAAa,aACjDtE,QAAQhB,UAAU8H,QAAQxC,WAAa,KAG9Cd,MAAMyD,QAAQjH,QAAQhB,UAAU8H,UACK,IAArC9G,QAAQhB,UAAU8H,QAAQC,QACO,iBAAjC/G,QAAQhB,UAAU8H,QAAQ,WAEnB9G,QAAQhB,UAAU8H,kBAexBnB,gBAAgBmB,OAAQ/G,MAAOuE,WAAYS,SAAUmC,uBAAwBlI,UAChF+F,SAASgC,QAAU,GACjBD,QAAUxC,aACPtE,QAAQhB,UAAU8H,UACrB9G,QAAQhB,UAAU8H,QAAU,IAEzB9G,QAAQhB,UAAU8H,QAAQxC,cAC7BtE,QAAQhB,UAAU8H,QAAQxC,YAAc,IAE1CtE,QAAQhB,UAAU8H,QAAQxC,YAAYS,UAAYhF,MAC9CgG,OAAOC,KAAKkB,wBAAwBH,OAAS,IAC/C/G,QAAQhB,UAAU8H,QAAQxC,WAAa,KAAO4C,kCAY7CtB,gCAAgCuB,KAAMC,KAAMpI,UAC/CgB,QAAQhB,UAAUmI,OAChBnH,QAAQhB,UAAUmI,MAAMC,OACtBrB,OAAOC,KAAKhG,QAAQhB,UAAUmI,MAAMC,OAAOL,OAAS,UAC/C/G,QAAQhB,UAAUmI,MAAMC,MAKjCpH,QAAQhB,UAAUmI,OAChBpB,OAAOC,KAAKhG,QAAQhB,UAAUmI,OAAOJ,OAAS,UACzC/G,QAAQhB,UAAUmI,eAWfxC,+BAA+BN,qBAAiB+B,0DAAK,GAE/DI,WAAanC,gBAAgBjF,cAAc,2BAA6BgH,GAAK,MAC7EiB,KAAOb,WAAWzG,MAElB4G,WAAatC,gBAAgBjF,cAAc,2BAA6BgH,GAAK,MAC7EkB,KAAOX,WAAW5G,MAElBwH,cAAgBhB,KAAKiB,MAAMH,KAAO,IAAMC,aACpBC,uBA0GVpF,WAAWC,KAAMrD,SAAUC,gBAGnCyI,QAAUtI,SAASC,cAAcL,UAEvCiB,QAAQhB,UAAUoD,MAAQoB,MAAMC,KAC9BgE,QAAQ5F,iBAAiB,cAAgBO,KAAO,MAChDsF,QAAO,SAAS9E,WACTA,GAAG5C,WACT2H,KAAI,SAAS/E,WACPA,GAAG7C,SAIRC,QAAQhB,UAAUoD,MAAM2E,OAAS,UAC5B/G,QAAQhB,UAAUoD,MAG3B+D,oBAAoB/D,KAAMrD,SAAUC,mBAStBkF,YAAYzD,EAAG1B,SAAUC,cAGnCqF,gBAAkB5D,EAAE0C,OAAOX,QAAQ,iBAGnCoF,UADOvD,gBAAgBjF,cAAc,8CACpBW,MAEjB8H,QADKxD,gBAAgBjF,cAAc,4CACtBW,MACb+H,QAAUrH,EAAE0C,OAAOzB,QAAQ0C,iBAGzB2D,MAASC,MAAUC,MAAMC,SAASF,OAASG,SAASH,MAAyB,KAAfA,IAAII,QAA2B,OAARJ,IAErFK,aAAehE,gBAAgBjF,cAAc,mCAC9C2I,MAAMH,YACLG,MAAMF,UAIVQ,aAAaC,aAAa,SAAU,QAGpCV,UAAYM,SAASN,UAAW,IAChCA,UAAYA,UAAU7G,WACtB8G,QAAUK,SAASL,QAAS,IAC5BA,QAAUA,QAAQ9G,YARlBsH,aAAaE,gBAAgB,WAW3BX,UAAUb,OAAS,GAAKc,QAAQd,OAAS,KAC3C/G,QAAQhB,UAAU8I,SAAWF,UAAY,IAAMC,SAI5CxD,gBAAgBjF,cAAc,0DAA0DY,gBACpFA,QAAQhB,UAAU8I,SAE3B3B,oBAAoB2B,QAAS/I,SAAUC,mBAQzBmF,iBAAiBnF,eAEzBA,YAAYgB,eACT,OAGLwI,WAAY,MAEX,OAASzI,SAAUgG,OAAO0C,QAAQzI,QAAQhB,YAEzCe,MAAMgH,OAAS,GAAKhB,OAAOC,KAAKjG,OAAOgH,OAAS,KAClDyB,WAAY,UAIXA,UAGEE,KAAKC,UAAU3I,QAAQhB,WAFrB,YA2CFmH,oBAAoB/D,KAAMrD,SAAUC,gBAErCyI,QAAUtI,SAASC,cAAcL,cAEnC6J,QAAU5I,QAAQhB,UAAUoD,MAAQpC,QAAQhB,UAAUoD,MAAM2E,OAAS,GACpE6B,QAAU,GAAyC,iBAA5B5I,QAAQhB,UAAUoD,OACR,iBAA5BpC,QAAQhB,UAAUoD,QAAuBoB,MAAMyD,QAAQjH,QAAQhB,UAAUoD,UAGjFwG,QAAU,SAGNC,aAAepB,QAAQrI,cAAc,eAAiBgD,KAAO,wBAE/DyG,eAEED,QAAU,EACZC,aAAaC,UAAUpJ,OAAO,UAE9BmJ,aAAaC,UAAUC,IAAI,UAE7BF,aAAaG,YAAcJ,eAGvBK,mBAAqBjJ,QAAQhB,UAAY+G,OAAOC,KAAKhG,QAAQhB,WAAW+H,OAAS,EACjFmC,aAAezB,QAAQrI,cAAc,wBAEvC8J,eACED,mBAAqB,EACvBC,aAAaJ,UAAUpJ,OAAO,UAE9BwJ,aAAaJ,UAAUC,IAAI,iCA/DL,CAACI,WAAYnK,SAAUC,sBAI3CF,SAAWyC,gBAAU4H,UAAYpK,SACjCE,UAAYC,SAASC,cAAcL,UACjBG,UAAUE,cAAcoC,gBAAUC,4BAMhD4H,iBAAiB,gCAAiCF,YAAYG,MAAKC,WAACC,KAACA,WAE7EtK,UAAUuK,mBAAmB,aAAcD,MAC3ClI,qBAAqBvC,SAAUC,SAAUC,iBAExCyK,OAAMjJ,IAEPnB,QAAQC,IAAIkB"}