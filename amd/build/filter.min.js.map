{"version":3,"file":"filter.min.js","sources":["../src/filter.js"],"sourcesContent":["\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    local_wunderbyte_table\n * @copyright  Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getSearchInput} from 'local_wunderbyte_table/search';\nimport {getSortSelection} from 'local_wunderbyte_table/sort';\n\nimport {callLoadData, SELECTORS} from 'local_wunderbyte_table/init';\nimport Templates from 'core/templates';\n\n// These variables are specific to the filter.\nvar checked = {};\n\n/**\n * Initialize Checkboxes.\n * @param {string} selector\n * @param {string} idstring\n * @param {string} encodedtable\n */\n export function initializeCheckboxes(selector, idstring, encodedtable) {\n\n  const filterContainer = document.querySelector(selector + SELECTORS.FILTER);\n\n  if (!filterContainer || filterContainer.dataset.initialized) {\n    return;\n  }\n  const selects = filterContainer.querySelectorAll(\"select[id^='filteroperationselect']\");\n  const filterElements = filterContainer.querySelectorAll(\"input[class^='filterelement']\");\n\n  if (!filterElements) {\n      return;\n  }\n\n  // We create the key for the checked items of this table.\n  if (!checked.hasOwnProperty(idstring)) {\n    checked[idstring] = {};\n  }\n\n  filterElements.forEach(el => {\n\n      if (!el.dataset.idstring) {\n        el.dataset.idstring = idstring;\n      } else {\n        el.dataset.idstring2 = idstring;\n      }\n      el.addEventListener(\"change\", (e) => toggleFilterelement(e, selector, idstring, encodedtable));\n  });\n\n  if (selects) {\n    selects.forEach(el => {\n\n      if (!el.dataset.idstring) {\n        el.dataset.idstring = idstring;\n      } else {\n        el.dataset.idstring2 = idstring;\n      }\n      el.addEventListener(\"change\", (e) => toggleFilterelement(e, selector, idstring, encodedtable));\n    });\n  }\n\n  filterContainer.dataset.initialized = true;\n}\n\n\n/**\n * Eventhandler\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n * @param {*} encodedtable\n */\n export function toggleFilterelement(e, selector, idstring, encodedtable) {\n\n  e.stopPropagation();\n  e.preventDefault();\n\n  // Check if Checkbox corresponds to datepicker\n  if (e.target.dataset.dateelement == 'dateelement') {\n    // eslint-disable-next-line no-console\n    console.log(\"dateelement\");\n    getDates(e, selector, idstring);\n  } else {\n    getChecked(e.target.name, selector, idstring);\n  }\n\n\n  // Reload the filtered elements via ajax.\n\n  const filterobjects = getFilterObjects(idstring);\n  const searchstring = getSearchInput(idstring);\n  const sort = getSortSelection(idstring);\n\n  // The filter reloads data from the Server.\n  // Because of pages and infinite scroll we don't have the data to do without.\n  callLoadData(idstring,\n    encodedtable,\n    0, // Pagenumber is always rest to 0.\n    null,\n    sort,\n    null,\n    null,\n    null,\n    filterobjects,\n    searchstring);\n}\n\n\n/**\n * Check if the checkbox of the filterparam is checked and if so write values from date- and timepicker into checked variable.\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n */\nexport function getDates(e, selector, idstring) {\n\n  let name = e.target.name;\n  let filtercontainer = e.target.closest(\".datepickerform\");\n  let filtername = e.target.dataset.filtername;\n  let filtercheckbox = filtercontainer.querySelector('input[type=\"checkbox\"][id^=\"' + filtername + '\"][name=\"' + name + '\"]');\n\n  let dates = {};\n  if (filtercheckbox.checked) {\n    // Check how many date- and timepicker are there\n    if (filtercheckbox.dataset.timespan === \"true\") {\n      setTimespanFilter(filtercontainer, filtername, idstring, name);\n    } else {\n      dates[filtercheckbox.dataset.operator] = getDateAndTimePickerDataAsUnix(filtercontainer, \"datefilter\");\n      // Check if key is set in array, otherwise set new key.\n      if (name && filtername) {\n        if (!checked[idstring][name]) {\n          checked[idstring][name] = {};\n        }\n        checked[idstring][name][filtername] = dates;\n      }\n      unsetCheckedObject(name, filtername, idstring);\n    }\n  }\n  // eslint-disable-next-line no-console\n  console.log(checked);\n}\n\n/**\n * Applying a timespan filter.\n * @param {*} filtercontainer\n * @param {string} filtername\n * @param {string} idstring\n * @param {string} name\n */\nfunction setTimespanFilter(filtercontainer, filtername, idstring, name) {\n\n      // Selector defined the operators.\n      let select = filtercontainer.querySelector('select[id^=\"filteroperationselect\"][name=\"' + name + '\"]');\n      let operator = select.value;\n\n      // First Column to apply the filter to\n      let startdatepicker = filtercontainer.querySelector('input[id^=\"startdate\"]');\n      let firstcolumn = startdatepicker.dataset.applytocolumn;\n      let firstoperator = \"\";\n      let firstColumnValues = {};\n      let additionalFirstColumnValues = {};\n      let valuefirstcolumn = getDateAndTimePickerDataAsUnix(filtercontainer, \"startdate\");\n\n      // Second Column to apply the filter to\n      let enddatepicker = filtercontainer.querySelector('input[id^=\"enddate\"]');\n      let secondcolumn = enddatepicker.dataset.applytocolumn;\n      let secondoperator = \"\";\n      let secondColumnValues = {};\n      let additionalSecondColumnValues = {};\n      let valuesecondcolumn = getDateAndTimePickerDataAsUnix(filtercontainer, \"enddate\");\n\n      // If we applied this timespan filter before, unset it.\n      if (checked.hasOwnProperty(filtername)) {\n        unsetCheckedObject(firstcolumn, filtername, idstring);\n        unsetCheckedObject(secondcolumn, filtername, idstring);\n      }\n\n      switch (operator) {\n        case \"within\":\n          // eslint-disable-next-line no-console\n          console.log(\"within switch operator\");\n          firstoperator = \">=\";\n          secondoperator = \"<=\";\n          break;\n        case \"overlapboth\":\n          // eslint-disable-next-line no-console\n          console.log(\"overlap both switch operator\");\n          firstoperator = \"<=\";\n          secondoperator = \">=\";\n          break;\n        case \"overlapstart\":\n          // eslint-disable-next-line no-console\n          console.log(\"overlap start switch operator\");\n          firstoperator = \"<=\";\n          additionalFirstColumnValues[\">=\"] = valuesecondcolumn;\n          secondoperator = \"<=\";\n          break;\n        case \"overlapend\":\n          // eslint-disable-next-line no-console\n          console.log(\"overlap end switch operator\");\n          firstoperator = \"<=\";\n          secondoperator = \"<=\";\n          additionalSecondColumnValues[\"<=\"] = valuefirstcolumn;\n          break;\n        case \"before\":\n          // eslint-disable-next-line no-console\n          console.log(\"before switch operator\");\n          firstoperator = \"<\";\n          additionalFirstColumnValues[\"<=\"] = valuesecondcolumn;\n          break;\n        case \"after\":\n          // eslint-disable-next-line no-console\n          console.log(\"after end switch operator\");\n          secondoperator = \"<=\";\n          additionalSecondColumnValues[\">\"] = valuesecondcolumn;\n          break;\n        default:\n        // eslint-disable-next-line no-console\n        console.error(\"Value of selection not readable\");\n        break;\n      }\n\n      if (firstoperator.length >= 1) {\n        firstColumnValues[firstoperator] = valuefirstcolumn;\n      }\n      if (secondoperator.length >= 1) {\n        secondColumnValues[secondoperator] = valuesecondcolumn;\n      }\n      // Setting values for first columns.\n      // Check if key is set in array, otherwise set new key.\n      if (firstcolumn && filtername) {\n        if (!checked[idstring][firstcolumn]) {\n          checked[idstring][firstcolumn] = {};\n        }\n        checked[idstring][firstcolumn][filtername] = new Array(firstColumnValues);\n        if (Object.keys(additionalFirstColumnValues).length > 0) {\n          checked[idstring][firstcolumn][filtername].push(additionalFirstColumnValues);\n        }\n      }\n\n      // Setting values for second columns.\n      // Check if key is set in array, otherwise set new key.\n      if (secondcolumn && filtername) {\n        if (!checked[idstring][secondcolumn]) {\n          checked[idstring][secondcolumn] = {};\n        }\n        checked[idstring][secondcolumn][filtername] = new Array(secondColumnValues);\n        if (Object.keys(additionalSecondColumnValues).length > 0) {\n          checked[idstring][secondcolumn][filtername].push(additionalSecondColumnValues);\n        }\n      }\n      // Unsetting the timespan filter if empty\n      unsetCheckedObject(firstcolumn, filtername, idstring);\n      unsetCheckedObject(secondcolumn, filtername, idstring);\n}\n\n/**\n * Unsetting empty keys in checked object. If a filter param was created and deleted later on we will need this.\n * @param {*} key1\n * @param {*} key2\n * @param {string} idstring\n */\nfunction unsetCheckedObject(key1, key2, idstring) {\n\n  if (Array.isArray(Object.values(checked[idstring][key1][key2]))) {\n    if (Object.values(checked[idstring][key1][key2]['0']).length < 1) {\n    delete checked[idstring][key1][key2]['0'];\n    }\n  }\n\n  if (Object.keys(checked[idstring][key1][key2]).length < 1) {\n    delete checked[idstring][key1][key2];\n  }\n  if (Object.keys(checked[idstring][key1]).length < 1) {\n    delete checked[idstring][key1];\n  }\n}\n\n/**\n * Checking Date and Timepicker for corresponding element and returning Unix Code.\n * @param {*} filtercontainer\n * @param {string} id\n * @returns {string}\n */\nexport function getDateAndTimePickerDataAsUnix(filtercontainer, id = '') {\n\n  let datepicker = filtercontainer.querySelector('input[type=\"date\"][id*=\"' + id + '\"]');\n  let date = new Date(datepicker.value);\n\n  let timepicker = filtercontainer.querySelector('input[type=\"time\"][id*=\"' + id + '\"]');\n  let time = timepicker.value;\n\n  let dateTimeString = date.toISOString().split('T')[0] + 'T' + time + ':00.000Z';\n  let unixTimestamp = Date.parse(dateTimeString) / 1000;\n\n  return unixTimestamp;\n}\n\n/**\n * Generating and displaying filterparams in URL.\n * @param {string} filterobjects\n * @param {string} searchstring\n * @param {string} sort\n * @param {*} dir\n */\nexport function updateUrlWithFilterSearchSort(filterobjects, searchstring, sort, dir) {\n\n  const url = new URL(window.location.href);\n\n  url.search = \"\";\n  history.replaceState(null, '', url);\n\n  if (filterobjects) {\n    url.searchParams.append('wbtfilter', filterobjects);\n  }\n  if (searchstring !== \"\" &&\n  searchstring !== null) {\n    url.searchParams.append('wbtsearch', searchstring);\n  }\n  if (sort !== \"\" &&\n  sort !== null) {\n    url.searchParams.append('tsort', sort);\n  }\n  if (dir !== null &&\n    dir > 0) {\n    url.searchParams.append('tdir', dir);\n  }\n\n  window.history.pushState(null, null, url.toString());\n}\n\n  /**\n   * Gets an array of checkboxes for every table by idstring.\n   * @param {*} name\n   * @param {*} selector\n   * @param {*} idstring\n   */\n   export function getChecked(name, selector, idstring) {\n\n    // We might have more than one Table, therefore we first have to get all tables.\n\n    const wbTable = document.querySelector(selector);\n\n    checked[idstring][name] = Array.from(\n      wbTable.querySelectorAll(\"input[name=\" + name + \"]\")\n    ).filter(function(el) {\n      return el.checked;\n    }).map(function(el) {\n      return el.value;\n    });\n\n    // If there are no checked boxes, we unset the key alltogether.\n    if (checked[idstring][name].length < 1) {\n      delete checked[idstring][name];\n    }\n  }\n\n  /**\n * Returns json of active filters as json.\n * @param {*} idstring\n * @returns {string}\n */\nexport function getFilterObjects(idstring) {\n\n  if (!(idstring in checked)) {\n    return '';\n  }\n\n  let hasvalues = false;\n  // eslint-disable-next-line no-unused-vars\n\n  for (const [, value] of Object.entries(checked[idstring])) {\n\n    if (value.length > 0 || Object.keys(value).length > 0) {\n      hasvalues = true;\n    }\n  }\n\n  if (!hasvalues) {\n    return '';\n  }\n  return JSON.stringify(checked[idstring]);\n}\n\n/**\n * Render the checkboxes for the filer.\n * @param {string} filterjson\n * @param {string} idstring\n * @param {string} encodedtable\n */\n    export const renderFilter = (filterjson, idstring, encodedtable) => {\n\n    // We render the filter only once, so if we find it already, we don't render it.\n\n    const selector = SELECTORS.CONTAINER + idstring;\n    const container = document.querySelector(selector);\n    const filtercontainer = container.querySelector(SELECTORS.FILTER);\n\n    if (filtercontainer) {\n      return;\n    }\n\n    Templates.renderForPromise('local_wunderbyte_table/filter', filterjson).then(({html}) => {\n\n        container.insertAdjacentHTML('afterbegin', html);\n\n        initializeCheckboxes(selector, idstring, encodedtable);\n\n        return;\n    }).catch(e => {\n        // eslint-disable-next-line no-console\n        console.log(e);\n    });\n};"],"names":["filterobjects","searchstring","sort","dir","url","URL","window","location","href","search","history","replaceState","searchParams","append","pushState","toString","checked","initializeCheckboxes","selector","idstring","encodedtable","filterContainer","document","querySelector","SELECTORS","FILTER","dataset","initialized","selects","querySelectorAll","filterElements","hasOwnProperty","forEach","el","idstring2","addEventListener","e","toggleFilterelement","stopPropagation","preventDefault","target","dateelement","console","log","getDates","getChecked","name","getFilterObjects","filtercontainer","closest","filtername","filtercheckbox","dates","timespan","operator","value","firstcolumn","applytocolumn","firstoperator","firstColumnValues","additionalFirstColumnValues","valuefirstcolumn","getDateAndTimePickerDataAsUnix","secondcolumn","secondoperator","secondColumnValues","additionalSecondColumnValues","valuesecondcolumn","unsetCheckedObject","error","length","Array","Object","keys","push","setTimespanFilter","key1","key2","isArray","values","id","datepicker","date","Date","timepicker","time","dateTimeString","toISOString","split","unixTimestamp","parse","wbTable","from","filter","map","hasvalues","entries","JSON","stringify","filterjson","CONTAINER","container","renderForPromise","then","_ref","html","insertAdjacentHTML","catch"],"mappings":"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"}