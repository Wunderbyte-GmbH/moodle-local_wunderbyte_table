{"version":3,"sources":["../src/filter.js"],"names":["checked","initializeCheckboxes","selector","idstring","encodedtable","filterContainer","document","querySelector","dataset","initialized","allCheckboxes","querySelectorAll","hasOwnProperty","forEach","el","addEventListener","e","toggleCheckbox","getChecked","target","name","filterobjects","getFilterOjects","searchstring","sort","wbTable","Array","from","map","value","JSON","stringify","renderFilter","filterjson","container","filtercontainer","Templates","renderForPromise","then","html","insertAdjacentHTML","catch","console","log"],"mappings":"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","sourcesContent":["\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    local_wunderbyte_table\n * @copyright  Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getSearchInput} from 'local_wunderbyte_table/search';\nimport {getSortSelection} from 'local_wunderbyte_table/sort';\n\nimport {callLoadData} from 'local_wunderbyte_table/init';\nimport Templates from 'core/templates';\n\n// These variables are specific to the filter.\nvar checked = {};\n// var categories = {};\n\n/**\n * Initialize Checkboxes.\n * @param {string} selector\n * @param {string} idstring\n * @param {string} encodedtable\n */\n export function initializeCheckboxes(selector, idstring, encodedtable) {\n\n  const filterContainer = document.querySelector(selector + \" .wunderbyteTableFilter\");\n\n  if (!filterContainer || filterContainer.dataset.initialized) {\n    return;\n  }\n\n  const allCheckboxes = filterContainer.querySelectorAll(\"input[type=checkbox]\");\n\n  if (!allCheckboxes) {\n      return;\n  }\n\n  // We create the key for the checked items of this table.\n  if (!checked.hasOwnProperty(idstring)) {\n    checked[idstring] = {};\n  }\n\n  // filterContainer.querySelectorAll(\".form-group\").forEach(e => {\n\n  //     if (!categories || !categories.hasOwnProperty(idstring)) {\n  //       categories[idstring] = [];\n  //     }\n\n  //     categories[idstring].push(e.getAttribute(\"name\"));\n  //     getChecked(e.getAttribute(\"name\"), selector, idstring);\n  // });\n\n  allCheckboxes.forEach(el => {\n      el.addEventListener(\"change\", (e) => toggleCheckbox(e, selector, idstring, encodedtable));\n  });\n\n  filterContainer.dataset.initialized = true;\n}\n\n\n/**\n * Eventhandler\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n* @param {*} encodedtable\n */\n export function toggleCheckbox(e, selector, idstring, encodedtable) {\n\n  getChecked(e.target.name, selector, idstring);\n\n  // Reload the filtered elements via ajax.\n\n  const filterobjects = getFilterOjects(idstring);\n  const searchstring = getSearchInput(idstring);\n  const sort = getSortSelection(idstring);\n\n  // The filter reloads data from the Server.\n  // Because of pages and infinite scroll we don't have the data to do without.\n  callLoadData(idstring,\n    encodedtable,\n    0, // Pagenumber is always rest to 0.\n    null,\n    sort,\n    null,\n    null,\n    null,\n    filterobjects,\n    searchstring);\n}\n\n  /**\n   * Gets an array of checkboxes for every table by idstring.\n   * @param {*} name\n   * @param {*} selector\n   * @param {*} idstring\n   * @returns {array}\n   */\n   export function getChecked(name, selector, idstring) {\n\n    // We might have more than one Table, therefore we first have to get all tables.\n\n    const wbTable = document.querySelector(selector);\n\n    checked[idstring][name] = Array.from(\n      wbTable.querySelectorAll(\"input[name=\" + name + \"]:checked\")\n    ).map(function(el) {\n      return el.value;\n    });\n\n  }\n\n  /**\n * Returns json of active filters as json.\n * @param {*} idstring\n * @returns {string}\n */\nexport function getFilterOjects(idstring) {\n\n  if (!(idstring in checked)) {\n    return '';\n  }\n\n  return JSON.stringify(checked[idstring]);\n}\n\n    /**\n   * Render the checkboxes for the filer.\n   * @param {string} filterjson\n   * @param {string} idstring\n   * @param {string} encodedtable\n   */\n     export const renderFilter = (filterjson, idstring, encodedtable) => {\n\n      // We render the filter only once, so if we find it already, we don't render it.\n\n      const selector = \".wunderbyte_table_container_\" + idstring;\n      const container = document.querySelector(selector);\n      const filtercontainer = container.querySelector(\".wunderbyteTableFilter\");\n\n      if (filtercontainer) {\n        return;\n      }\n\n      Templates.renderForPromise('local_wunderbyte_table/filter', filterjson).then(({html}) => {\n\n          container.insertAdjacentHTML('afterbegin', html);\n\n          initializeCheckboxes(selector, idstring, encodedtable);\n\n          return;\n      }).catch(e => {\n          // eslint-disable-next-line no-console\n          console.log(e);\n      });\n  };"],"file":"filter.min.js"}