{"version":3,"file":"filter.min.js","sources":["../src/filter.js"],"sourcesContent":["\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    local_wunderbyte_table\n * @copyright  Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getSearchInput} from 'local_wunderbyte_table/search';\nimport {getSortSelection} from 'local_wunderbyte_table/sort';\n\nimport {callLoadData} from 'local_wunderbyte_table/init';\nimport Templates from 'core/templates';\n\n// These variables are specific to the filter.\nvar checked = {};\n\n/**\n * Initialize Checkboxes.\n * @param {string} selector\n * @param {string} idstring\n * @param {string} encodedtable\n */\n export function initializeCheckboxes(selector, idstring, encodedtable) {\n\n  const filterContainer = document.querySelector(selector + \" .wunderbyteTableFilter\");\n\n  if (!filterContainer || filterContainer.dataset.initialized) {\n    return;\n  }\n\n  const allCheckboxes = filterContainer.querySelectorAll(\"input[type=checkbox]\");\n\n  if (!allCheckboxes) {\n      return;\n  }\n\n  // We create the key for the checked items of this table.\n  if (!checked.hasOwnProperty(idstring)) {\n    checked[idstring] = {};\n  }\n\n  // filterContainer.querySelectorAll(\".form-group\").forEach(e => {\n\n  //     if (!categories || !categories.hasOwnProperty(idstring)) {\n  //       categories[idstring] = [];\n  //     }\n\n  //     categories[idstring].push(e.getAttribute(\"name\"));\n  //     getChecked(e.getAttribute(\"name\"), selector, idstring);\n  // });\n\n  allCheckboxes.forEach(el => {\n\n      if (!el.dataset.idstring) {\n        el.dataset.idstring = idstring;\n      } else {\n        el.dataset.idstring2 = idstring;\n      }\n\n      el.addEventListener(\"change\", (e) => toggleCheckbox(e, selector, idstring, encodedtable));\n  });\n\n  filterContainer.dataset.initialized = true;\n}\n\n\n/**\n * Eventhandler\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n* @param {*} encodedtable\n */\n export function toggleCheckbox(e, selector, idstring, encodedtable) {\n\n  e.stopPropagation();\n  e.preventDefault();\n\n  getChecked(e.target.name, selector, idstring);\n\n  // Reload the filtered elements via ajax.\n\n  const filterobjects = getFilterObjects(idstring);\n  const searchstring = getSearchInput(idstring);\n  const sort = getSortSelection(idstring);\n\n  // The filter reloads data from the Server.\n  // Because of pages and infinite scroll we don't have the data to do without.\n  callLoadData(idstring,\n    encodedtable,\n    0, // Pagenumber is always rest to 0.\n    null,\n    sort,\n    null,\n    null,\n    null,\n    filterobjects,\n    searchstring);\n\n    updateUrl(filterobjects, searchstring, sort);\n}\n\n/**\n * Generating and displaying filterparams in URL.\n * @param {string} filterobjects\n * @param {string} searchstring\n * @param {string} sort\n */\nfunction updateUrl(filterobjects, searchstring, sort) {\n\n  let url = new URL(window.location.href);\n\n  url.searchParams.delete('wbtfilter');\n  url.searchParams.delete('wbtsearch');\n  url.searchParams.delete('wbtsort');\n\n  url.searchParams.append('wbtfilter', filterobjects);\n  url.searchParams.append('wbtsearch', searchstring);\n  url.searchParams.append('wbtsort', sort);\n\n  window.history.pushState(null, null, url.toString());\n}\n\n  /**\n   * Gets an array of checkboxes for every table by idstring.\n   * @param {*} name\n   * @param {*} selector\n   * @param {*} idstring\n   */\n   export function getChecked(name, selector, idstring) {\n\n    // We might have more than one Table, therefore we first have to get all tables.\n\n    const wbTable = document.querySelector(selector);\n\n    checked[idstring][name] = Array.from(\n      wbTable.querySelectorAll(\"input[name=\" + name + \"]:checked\")\n    ).map(function(el) {\n      return el.value;\n    });\n\n  }\n\n  /**\n * Returns json of active filters as json.\n * @param {*} idstring\n * @returns {string}\n */\nexport function getFilterObjects(idstring) {\n\n  if (!(idstring in checked)) {\n    return '';\n  }\n\n  return JSON.stringify(checked[idstring]);\n}\n\n/**\n * Render the checkboxes for the filer.\n * @param {string} filterjson\n * @param {string} idstring\n * @param {string} encodedtable\n */\n    export const renderFilter = (filterjson, idstring, encodedtable) => {\n\n    // We render the filter only once, so if we find it already, we don't render it.\n\n    const selector = \".wunderbyte_table_container_\" + idstring;\n    const container = document.querySelector(selector);\n    const filtercontainer = container.querySelector(\".wunderbyteTableFilter\");\n\n    if (filtercontainer) {\n      return;\n    }\n\n    Templates.renderForPromise('local_wunderbyte_table/filter', filterjson).then(({html}) => {\n\n        container.insertAdjacentHTML('afterbegin', html);\n\n        initializeCheckboxes(selector, idstring, encodedtable);\n\n        return;\n    }).catch(e => {\n        // eslint-disable-next-line no-console\n        console.log(e);\n    });\n};"],"names":["checked","initializeCheckboxes","selector","idstring","encodedtable","filterContainer","document","querySelector","dataset","initialized","allCheckboxes","querySelectorAll","hasOwnProperty","forEach","el","idstring2","addEventListener","e","toggleCheckbox","stopPropagation","preventDefault","getChecked","target","name","filterobjects","getFilterObjects","searchstring","sort","url","URL","window","location","href","searchParams","delete","append","history","pushState","toString","updateUrl","wbTable","Array","from","map","value","JSON","stringify","filterjson","container","renderForPromise","then","_ref","html","insertAdjacentHTML","catch","console","log"],"mappings":";;;;;gUA6BIA,QAAU,YAQGC,qBAAqBC,SAAUC,SAAUC,oBAElDC,gBAAkBC,SAASC,cAAcL,SAAW,+BAErDG,iBAAmBA,gBAAgBG,QAAQC,yBAI1CC,cAAgBL,gBAAgBM,iBAAiB,wBAElDD,gBAKAV,QAAQY,eAAeT,YAC1BH,QAAQG,UAAY,IAatBO,cAAcG,SAAQC,KAEbA,GAAGN,QAAQL,SAGdW,GAAGN,QAAQO,UAAYZ,SAFvBW,GAAGN,QAAQL,SAAWA,SAKxBW,GAAGE,iBAAiB,UAAWC,GAAMC,eAAeD,EAAGf,SAAUC,SAAUC,mBAG/EC,gBAAgBG,QAAQC,aAAc,YAWvBS,eAAeD,EAAGf,SAAUC,SAAUC,cAErDa,EAAEE,kBACFF,EAAEG,iBAEFC,WAAWJ,EAAEK,OAAOC,KAAMrB,SAAUC,gBAI9BqB,cAAgBC,iBAAiBtB,UACjCuB,cAAe,0BAAevB,UAC9BwB,MAAO,0BAAiBxB,iCAIjBA,SACXC,aACA,EACA,KACAuB,KACA,KACA,KACA,KACAH,cACAE,uBAWeF,cAAeE,aAAcC,UAE1CC,IAAM,IAAIC,IAAIC,OAAOC,SAASC,MAElCJ,IAAIK,aAAaC,OAAO,aACxBN,IAAIK,aAAaC,OAAO,aACxBN,IAAIK,aAAaC,OAAO,WAExBN,IAAIK,aAAaE,OAAO,YAAaX,eACrCI,IAAIK,aAAaE,OAAO,YAAaT,cACrCE,IAAIK,aAAaE,OAAO,UAAWR,MAEnCG,OAAOM,QAAQC,UAAU,KAAM,KAAMT,IAAIU,YArBvCC,CAAUf,cAAeE,aAAcC,eA8BxBN,WAAWE,KAAMrB,SAAUC,gBAIpCqC,QAAUlC,SAASC,cAAcL,UAEvCF,QAAQG,UAAUoB,MAAQkB,MAAMC,KAC9BF,QAAQ7B,iBAAiB,cAAgBY,KAAO,cAChDoB,KAAI,SAAS7B,WACNA,GAAG8B,kBAUAnB,iBAAiBtB,iBAEzBA,YAAYH,QAIX6C,KAAKC,UAAU9C,QAAQG,WAHrB,yBAYqB,CAAC4C,WAAY5C,SAAUC,sBAI7CF,SAAW,+BAAiCC,SAC5C6C,UAAY1C,SAASC,cAAcL,UACjB8C,UAAUzC,cAAc,8CAMtC0C,iBAAiB,gCAAiCF,YAAYG,MAAKC,WAACC,KAACA,WAE3EJ,UAAUK,mBAAmB,aAAcD,MAE3CnD,qBAAqBC,SAAUC,SAAUC,iBAG1CkD,OAAMrC,IAELsC,QAAQC,IAAIvC"}