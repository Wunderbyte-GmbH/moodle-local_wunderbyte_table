{"version":3,"file":"filter.min.js","sources":["../src/filter.js"],"sourcesContent":["\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    local_wunderbyte_table\n * @copyright  Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getSearchInput} from 'local_wunderbyte_table/search';\nimport {getSortSelection} from 'local_wunderbyte_table/sort';\n\nimport {callLoadData} from 'local_wunderbyte_table/init';\nimport Templates from 'core/templates';\n\n// These variables are specific to the filter.\nvar checked = {};\n// var categories = {};\n\n/**\n * Initialize Checkboxes.\n * @param {string} selector\n * @param {string} idstring\n * @param {string} encodedtable\n */\n export function initializeCheckboxes(selector, idstring, encodedtable) {\n\n  const filterContainer = document.querySelector(selector + \" .wunderbyteTableFilter\");\n\n  if (!filterContainer || filterContainer.dataset.initialized) {\n    return;\n  }\n\n  const allCheckboxes = filterContainer.querySelectorAll(\"input[type=checkbox]\");\n\n  if (!allCheckboxes) {\n      return;\n  }\n\n  // We create the key for the checked items of this table.\n  if (!checked.hasOwnProperty(idstring)) {\n    checked[idstring] = {};\n  }\n\n  // filterContainer.querySelectorAll(\".form-group\").forEach(e => {\n\n  //     if (!categories || !categories.hasOwnProperty(idstring)) {\n  //       categories[idstring] = [];\n  //     }\n\n  //     categories[idstring].push(e.getAttribute(\"name\"));\n  //     getChecked(e.getAttribute(\"name\"), selector, idstring);\n  // });\n\n  allCheckboxes.forEach(el => {\n      el.addEventListener(\"change\", (e) => toggleCheckbox(e, selector, idstring, encodedtable));\n  });\n\n  filterContainer.dataset.initialized = true;\n}\n\n\n/**\n * Eventhandler\n * @param {*} e\n * @param {*} selector\n * @param {*} idstring\n* @param {*} encodedtable\n */\n export function toggleCheckbox(e, selector, idstring, encodedtable) {\n\n  // eslint-disable-next-line no-console\n  console.log('checked', e.target.name);\n  getChecked(e.target.name, selector, idstring);\n\n  // eslint-disable-next-line no-console\n  console.log('checked', checked);\n\n  // Reload the filtered elements via ajax.\n\n  const filterobjects = getFilterOjects(idstring);\n  const searchstring = getSearchInput(idstring);\n  const sort = getSortSelection(idstring);\n\n  // eslint-disable-next-line no-console\n  console.log('reload from filter ', filterobjects);\n\n  // The filter reloads data from the Server.\n  // Because of pages and infinite scroll we don't have the data to do without.\n  callLoadData(idstring,\n    encodedtable,\n    0, // Pagenumber is always rest to 0.\n    null,\n    sort,\n    null,\n    null,\n    null,\n    filterobjects,\n    searchstring);\n}\n\n  /**\n   * Gets an array of checkboxes for every table by idstring.\n   * @param {*} name\n   * @param {*} selector\n   * @param {*} idstring\n   * @returns {array}\n   */\n   export function getChecked(name, selector, idstring) {\n\n    // We might have more than one Table, therefore we first have to get all tables.\n\n    const wbTable = document.querySelector(selector);\n\n    checked[idstring][name] = Array.from(\n      wbTable.querySelectorAll(\"input[name=\" + name + \"]:checked\")\n    ).map(function(el) {\n      return el.value;\n    });\n\n    // eslint-disable-next-line no-console\n    console.log(\"after every step \", checked[idstring]);\n  }\n\n  /**\n * Returns json of active filters as json.\n * @param {*} idstring\n * @returns {string}\n */\nexport function getFilterOjects(idstring) {\n\n  // eslint-disable-next-line no-console\n  console.log(checked[idstring]);\n\n  const test = {\n    'sport': [\n      'eins', 'zwei', 'drei']\n  };\n\n  // eslint-disable-next-line no-console\n  console.log(test, JSON.stringify(test));\n\n  const testzwei = JSON.stringify(checked[idstring]);\n\n  // eslint-disable-next-line no-console\n  console.log(testzwei);\n\n  return JSON.stringify(checked[idstring]);\n}\n\n    /**\n   * Render the checkboxes for the filer.\n   * @param {string} filterjson\n   * @param {string} idstring\n   * @param {string} encodedtable\n   */\n     export const renderFilter = (filterjson, idstring, encodedtable) => {\n\n      // We render the filter only once, so if we find it already, we don't render it.\n\n      // eslint-disable-next-line no-console\n      console.log(idstring);\n\n      const selector = \".wunderbyte_table_container_\" + idstring;\n      const container = document.querySelector(selector);\n      const filtercontainer = container.querySelector(\".wunderbyteTableFilter\");\n\n      if (filtercontainer) {\n        return;\n      }\n\n      Templates.renderForPromise('local_wunderbyte_table/filter', filterjson).then(({html}) => {\n\n          // eslint-disable-next-line no-console\n          console.log(\"encodedtable: \", encodedtable);\n\n          container.insertAdjacentHTML('afterbegin', html);\n\n          initializeCheckboxes(selector, idstring, encodedtable);\n\n          return;\n      }).catch(e => {\n          // eslint-disable-next-line no-console\n          console.log(e);\n      });\n  };"],"names":["checked","initializeCheckboxes","selector","idstring","encodedtable","filterContainer","document","querySelector","dataset","initialized","allCheckboxes","querySelectorAll","hasOwnProperty","forEach","el","addEventListener","e","toggleCheckbox","console","log","target","name","getChecked","filterobjects","getFilterOjects","searchstring","sort","wbTable","Array","from","map","value","test","JSON","stringify","testzwei","filterjson","container","renderForPromise","then","_ref","html","insertAdjacentHTML","catch"],"mappings":";;;;;8TA6BIA,QAAU,YASGC,qBAAqBC,SAAUC,SAAUC,oBAElDC,gBAAkBC,SAASC,cAAcL,SAAW,+BAErDG,iBAAmBA,gBAAgBG,QAAQC,yBAI1CC,cAAgBL,gBAAgBM,iBAAiB,wBAElDD,gBAKAV,QAAQY,eAAeT,YAC1BH,QAAQG,UAAY,IAatBO,cAAcG,SAAQC,KAClBA,GAAGC,iBAAiB,UAAWC,GAAMC,eAAeD,EAAGd,SAAUC,SAAUC,mBAG/EC,gBAAgBG,QAAQC,aAAc,YAWvBQ,eAAeD,EAAGd,SAAUC,SAAUC,cAGrDc,QAAQC,IAAI,UAAWH,EAAEI,OAAOC,MAChCC,WAAWN,EAAEI,OAAOC,KAAMnB,SAAUC,UAGpCe,QAAQC,IAAI,UAAWnB,eAIjBuB,cAAgBC,gBAAgBrB,UAChCsB,cAAe,0BAAetB,UAC9BuB,MAAO,0BAAiBvB,UAG9Be,QAAQC,IAAI,sBAAuBI,sCAItBpB,SACXC,aACA,EACA,KACAsB,KACA,KACA,KACA,KACAH,cACAE,uBAUeH,WAAWD,KAAMnB,SAAUC,gBAIpCwB,QAAUrB,SAASC,cAAcL,UAEvCF,QAAQG,UAAUkB,MAAQO,MAAMC,KAC9BF,QAAQhB,iBAAiB,cAAgBU,KAAO,cAChDS,KAAI,SAAShB,WACNA,GAAGiB,SAIZb,QAAQC,IAAI,oBAAqBnB,QAAQG,oBAQ7BqB,gBAAgBrB,UAG9Be,QAAQC,IAAInB,QAAQG,iBAEd6B,KAAO,OACF,CACP,OAAQ,OAAQ,SAIpBd,QAAQC,IAAIa,KAAMC,KAAKC,UAAUF,aAE3BG,SAAWF,KAAKC,UAAUlC,QAAQG,kBAGxCe,QAAQC,IAAIgB,UAELF,KAAKC,UAAUlC,QAAQG,iCASC,CAACiC,WAAYjC,SAAUC,gBAKlDc,QAAQC,IAAIhB,gBAEND,SAAW,+BAAiCC,SAC5CkC,UAAY/B,SAASC,cAAcL,UACjBmC,UAAU9B,cAAc,8CAMtC+B,iBAAiB,gCAAiCF,YAAYG,MAAKC,WAACC,KAACA,WAG3EvB,QAAQC,IAAI,iBAAkBf,cAE9BiC,UAAUK,mBAAmB,aAAcD,MAE3CxC,qBAAqBC,SAAUC,SAAUC,iBAG1CuC,OAAM3B,IAELE,QAAQC,IAAIH"}