{"version":3,"file":"init.min.js","sources":["../src/init.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    local_wunderbyte_table\n * @copyright Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\n\nimport {initializeCheckboxes, getFilterOjects} from 'local_wunderbyte_table/filter';\nimport {initializeSearch, getSearchInput} from 'local_wunderbyte_table/search';\nimport {initializeSort, getSortSelection} from 'local_wunderbyte_table/sort';\n\n// All these variables will be objects with the idstringso their tables as identifiers.\nvar loadings = {};\nvar scrollpages = {};\nvar tablejss = {};\n\n/**\n * Gets called from mustache template.\n * @param {string} idstring\n * @param {string} encodedtable\n */\nexport const init = (idstring, encodedtable) => {\n\n    // eslint-disable-next-line no-console\n    console.log('wb init', idstring);\n\n    if (idstring && encodedtable) {\n\n        if (!scrollpages.hasOwnProperty(idstring)) {\n            scrollpages[idstring] = 0;\n        }\n\n        respondToVisibility(idstring, encodedtable, callLoadData);\n    }\n};\n\n/**\n * React on visibility change.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {function} callback\n */\nfunction respondToVisibility(idstring, encodedtable, callback) {\n\n    const identifier = 'a' + idstring;\n    let element = document.querySelector('#' + identifier);\n\n    // If we find the table element AND if it has the encoded table set, we abort this.\n    // Hereby we avoid to run JS multiple times.\n    if (element && !element.dataset.encodedtable) {\n        element.dataset.encodedtable = encodedtable;\n    } else {\n        // eslint-disable-next-line no-console\n        console.log('wb didnnt find element aborted', identifier);\n        return;\n    }\n\n    // We only make this callback during init if there is the spinner running.\n    // We don't want to run all of this if we don't use lazyloading.\n    let spinner = document.querySelector(\"#\" + identifier + 'spinner');\n\n    if ((spinner !== null) && !isHidden(spinner)) {\n\n        var observer = new MutationObserver(function() {\n            if (!isHidden(element)) {\n                this.disconnect();\n\n                callback(idstring, encodedtable);\n            }\n        });\n\n        const hiddenElement = returnHiddenElement(element);\n\n        if (hiddenElement !== null) {\n\n            observer.observe(hiddenElement, {attributes: true});\n        } else {\n            callback(idstring, encodedtable);\n        }\n\n    } else {\n\n        // This is what we do when we didn't lazyload.\n        replaceLinksInFrag(idstring, encodedtable, element, null);\n\n        const selector = \".wunderbyte_table_container_\" + idstring;\n        initializeCheckboxes(selector, idstring, encodedtable);\n        initializeSearch(selector, idstring, encodedtable);\n        initializeSort(selector, idstring, encodedtable);\n\n        // Check to see if scrolling near bottom of page; load more photos\n        // This shoiuld only be added once.\n\n        // As this can only be here once per table, we mark the table.\n        addScrollFunctionality(idstring, encodedtable, element);\n\n        addReloadFunctionality(idstring, encodedtable, element);\n\n    }\n}\n\n/**\n * Return the next scrollable element.\n * @param {*} node\n * @returns {*} node\n */\nfunction getScrollParent(node) {\n    if (node === null) {\n      return null;\n    }\n\n    if (node.scrollHeight > node.clientHeight) {\n      return node;\n    } else {\n      return getScrollParent(node.parentNode);\n    }\n  }\n\n/**\n * Function to reload a wunderbyte table from js.\n * Here we trim the idstring before we pass it to the calldatafunction.\n * @param {*} idstringplusa\n * @param {*} encodedtable\n * @param {number} rowid\n */\nexport function wbTableReload(idstringplusa, encodedtable, rowid) {\n\n    // eslint-disable-next-line no-console\n    console.log(idstringplusa, rowid, encodedtable);\n\n    // We need to trim the first character. We use the a to make sure no number is in first place due to random generation.\n    const idstring = idstringplusa.substring(1);\n\n    let filterobjects = getFilterOjects(idstring);\n\n    // If we have a rowid, we add the rowid to the filter.\n    if (rowid > 0) {\n\n        let filterobject = {};\n\n        if (filterobjects.length !== 0) {\n            filterobject = JSON.parse(filterobjects);\n        }\n\n        filterobject.id = [rowid];\n        filterobjects = JSON.stringify(filterobject);\n    }\n\n    const replacerow = rowid > 0 ? true : false;\n\n    const searchstring = getSearchInput(idstring);\n    const sort = getSortSelection(idstring);\n\n    callLoadData(idstring,\n        encodedtable,\n        0, // Pagenumber is always rest to 0.\n        null,\n        sort,\n        null,\n        null,\n        null,\n        filterobjects,\n        searchstring,\n        replacerow);\n}\n\n/**\n * This function can be called from a button. The button identifies the table and the id and calls reload.\n * @param {HTMLElement} element\n */\nexport function wbTableRowReload(element) {\n\n    // eslint-disable-next-line no-console\n    console.log(element);\n\n    let parentelement = element;\n    let rowid = null;\n\n    // We run through the parents until we have the table class.\n    while (!parentelement.classList.contains('wunderbyteTableClass')) {\n        // We only want the first id, so we check if we have found an id already.\n        if (!rowid && parentelement.dataset.id) {\n            rowid = parentelement.dataset.id;\n        }\n        parentelement = parentelement.parentElement;\n\n        if (!parentelement) {\n            break;\n        }\n    }\n    // Only if we have found a parent element, we call reload.\n    if (parentelement) {\n        const idstring = parentelement.getAttribute('id');\n        const encodedtable = parentelement.dataset.encodedtable;\n\n        wbTableReload(idstring, encodedtable, rowid);\n    }\n\n}\n\n/**\n * Function to check visibility of element.\n * @param {*} el\n * @returns {boolean}\n */\n export const isHidden = (el) => {\n    var style = window.getComputedStyle(el);\n    return ((style.display === 'none') || (style.visibility === 'hidden'));\n};\n\n/**\n * Reloads the rendered table and sets it to the div with the right identifier.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {null|int} page\n * @param {null|string} tsort\n * @param {null|string} thide\n * @param {null|string} tshow\n * @param {null|int} tdir\n * @param {null|int} treset\n * @param {null|string} filterobjects\n * @param {null|string} searchtext\n * @param {null|bool} replacerow\n */\nexport const callLoadData = (\n    idstring,\n    encodedtable,\n    page = null,\n    tsort = null,\n    thide = null,\n    tshow = null,\n    tdir = null,\n    treset = null,\n    filterobjects = null,\n    searchtext = null,\n    replacerow = false) => {\n\n    if (loadings[idstring]) {\n        return;\n    }\n\n    // We reset scrollpage with 0 when we come from the filter.\n    if (page !== null) {\n        scrollpages[idstring] = page;\n    }\n\n    // We always have to see if we need to apply a filter. Reload might come from scroll, but filter has to be applied nevertheless.\n    if (filterobjects === null) {\n        filterobjects = getFilterOjects(idstring);\n    }\n    // We always have to see if we need to apply a serachtextfilter.\n    if (searchtext === null) {\n        searchtext = getSearchInput(idstring);\n    }\n    // We always have to see if we need to apply a sortorder.\n    if (tsort === null) {\n        tsort = getSortSelection(idstring);\n    }\n\n    let table = document.getElementById('a' + idstring);\n\n    // This is now the individual spinner from the wunderbyte table template.\n    let spinner = document.querySelector('#a' + idstring + 'spinner .spinner-border');\n\n    // If we replace the whole table, we show the spinner. If we only add rows in infinite scroll, we don't.\n    if (scrollpages[idstring] == 0\n            && !replacerow) {\n        if (spinner) {\n            spinner.classList.remove('hidden');\n        }\n        if (table) {\n            table.classList.add('hidden');\n        }\n    }\n\n    loadings[idstring] = true;\n\n    Ajax.call([{\n        methodname: \"local_wunderbyte_table_load_data\",\n        args: {\n            'encodedtable': encodedtable,\n            'page': page,\n            'tsort': tsort,\n            'thide': thide,\n            'tshow': tshow,\n            'tdir': tdir,\n            'treset': treset,\n            'filterobjects': filterobjects,\n            'searchtext': searchtext\n        },\n        done: function(res) {\n\n            let jsonobject = JSON.parse(res.content);\n            let rendertemplate = res.template;\n\n            // We can always expect a wunderbyte table container at this point.\n            // The container will hold wunderbyteTableClass, wunderbyteTableFilter, wunderbyteTableSearch classes.\n            let container = document.querySelector(\".wunderbyte_table_container_\" + idstring);\n            const componentscontainer = container.querySelector(\".wunderbyte_table_components\");\n\n            // If we only increase the scrollpage, we don't need to render everything again.\n            if (replacerow\n                || (scrollpages[idstring] > 0)) {\n\n                // Also, we want to use the table instead of the container template.\n                const rowtemplate = rendertemplate + '_row';\n\n                if (!jsonobject.table.hasOwnProperty('rows')) {\n                    // We set the scrollpage to -1 which means that we don't reload anymore.\n                    scrollpages[idstring] = -1;\n                    loadings[idstring] = false;\n                    return;\n                }\n                let rows = jsonobject.table.rows;\n\n                // We create an array of promises where every line is rendered individually.\n                const promises = rows.map(row => {\n                    Templates.renderForPromise(rowtemplate, row).then(({html, js}) => {\n\n                        if (replacerow) {\n\n                            // We need the id.\n                            const filterobject = JSON.parse(filterobjects);\n                            const rowid = filterobject.id;\n\n                            Templates.replaceNode(\"#a\" + idstring\n                                + \" .rows-container tr[data-id='\" + rowid + \"']\", html, js);\n                        } else {\n                            // Here we add the rendered content to the table div.\n                            Templates.appendNodeContents('#a' + idstring + \" .rows-container\", html, js);\n                        }\n\n                        return true;\n                    }).catch(e => {\n                        // eslint-disable-next-line no-console\n                        console.log(e);\n                    });\n                    return true;\n                });\n\n                if (!tablejss.hasOwnProperty(idstring)) {\n                    // eslint-disable-next-line no-unused-vars\n                    const promise = Templates.renderForPromise(rendertemplate, jsonobject).then(({html, js}) => {\n\n                        tablejss[idstring] = js;\n                        return true;\n                    }).catch(e => {\n                        // eslint-disable-next-line no-console\n                        console.log(e);\n                    });\n\n                    promises.push(promise);\n                }\n\n                // Once all the promises are fullfilled, we set loading to false.\n                Promise.all(promises).then(() => {\n\n                    setTimeout(() => {\n                        // We only added rows, but they might need some js from the table, so we add the table js again.\n                        Templates.appendNodeContents('#a' + idstring, '', tablejss[idstring]);\n\n                    }, 100);\n\n                    loadings[idstring] = false;\n\n                    return;\n                }).catch(e => {\n                    // eslint-disable-next-line no-console\n                    console.log(e);\n                });\n\n                return;\n\n            }\n\n            if (!componentscontainer) {\n                // If the componentscontainer is not yet rendered, we render the container. else, only the table.\n                rendertemplate = rendertemplate + '_container';\n            }\n\n            let frag = container.querySelector(\".wunderbyteTableClass\");\n\n            // We render the html with the right template.\n            Templates.renderForPromise(rendertemplate, jsonobject).then(({html, js}) => {\n\n                if (componentscontainer) {\n                    // Now we clean the existing table.\n                    while (frag.firstChild) {\n                        frag.removeChild(frag.lastChild);\n                    }\n\n                    // Here we add the rendered content to the table div.\n                    Templates.appendNodeContents('#a' + idstring, html, js);\n                } else {\n                    // Here we try to render the whole.hro\n                    const parent = container.parentElement;\n                    container.remove();\n                    Templates.appendNodeContents(parent, html, js);\n\n                    container = document.querySelector(\".wunderbyte_table_container_\" + idstring);\n                }\n\n                replaceLinksInFrag(idstring, encodedtable, container, page);\n\n                // When everything is done, we loaded fine.\n                loadings[idstring] = false;\n\n                if (spinner) {\n                    spinner.classList.add('hidden');\n                }\n                if (table) {\n                    table.classList.remove('hidden');\n                }\n\n                // Make sure all elements are working.\n                const selector = \".wunderbyte_table_container_\" + idstring;\n                initializeCheckboxes(selector, idstring, encodedtable);\n                initializeSearch(selector, idstring, encodedtable);\n                initializeSort(selector, idstring, encodedtable);\n\n                const element = container.querySelector('#a' + idstring);\n\n                // This is the place where we are after lazyloading. We check if we need to reinitialize scrolllistener:\n                addScrollFunctionality(idstring, encodedtable, element);\n                addReloadFunctionality(idstring, encodedtable, element);\n\n                return true;\n            }).catch(ex => {\n                loadings[idstring] = false;\n                Notification.addNotification({\n                    message: 'failed rendering ' + ex,\n                    type: \"danger\"\n                });\n            });\n        },\n        fail: function(err) {\n            // If we have an error, resetting the table might be enough. we do that.\n            // To avoid a loop, we only do this in special cases.\n            if ((treset != 1)) {\n                callLoadData(idstring, encodedtable, page, null, null, null, null, 1);\n            } else {\n                let node = document.createElement('DIV');\n                let textnode = document.createTextNode(err.message);\n                node.appendChild(textnode);\n                table.appendChild(node);\n                spinner.classList.add('hidden');\n                table.classList.remove('hidden');\n            }\n        }\n    }]);\n};\n\n/**\n * Add the scroll functionality to the right table.\n * @param {*} idstring\n * @param {*} encodedtable\n * @param {*} element\n * @returns {void}\n */\nfunction addScrollFunctionality(idstring, encodedtable, element) {\n\n    if (element.dataset.scrollinitialized) {\n        return;\n    }\n\n    element.dataset.scrollinitialized = true;\n\n    const scrollableelement = getScrollParent(element);\n\n    scrollableelement.addEventListener('scroll', () => {\n\n        // We only want to scroll, if the element is visible.\n        // So, if we find a hidden element in the parent, we don't scroll.\n        if (returnHiddenElement(element)) {\n            return;\n        }\n\n        const elementtop = element.getBoundingClientRect().top;\n        const elementheight = element.getBoundingClientRect().height;\n        const screenheight = document.body.scrollHeight;\n\n        if (!loadings[idstring] && scrollpages[idstring] >= 0) {\n            if (elementtop + elementheight - screenheight < 0) {\n                scrollpages[idstring] = scrollpages[idstring] + 1;\n                callLoadData(idstring,\n                        encodedtable,\n                        scrollpages[idstring],\n                        null,\n                        null,\n                        null,\n                        null,\n                        null,\n                        null,\n                        null);\n            }\n        }\n\n    });\n}\n\n/**\n *\n * @param {*} idstring\n * @param {*} encodedtable\n * @param {*} table\n */\nfunction addReloadFunctionality(idstring, encodedtable, table) {\n\n    let rowelements = table.querySelectorAll('tr td.id');\n\n    // eslint-disable-next-line no-console\n    console.log('addReloadFunctionality', rowelements);\n\n    rowelements.forEach(item => {\n\n        // eslint-disable-next-line no-console\n        console.log('addReloadFunctionality', item);\n\n        const rowid = item.innerHTML.trim();\n\n        // eslint-disable-next-line no-console\n        console.log('add reload row', rowid);\n\n        item.addEventListener('click', () => {\n            wbTableReload('a' + idstring, encodedtable, rowid);\n        });\n    });\n\n}\n\n/**\n * If the element or one of its parents is hidden, we return it. the hiddenn element.\n * Else we return null.\n * @param {node} element\n * @returns {null|node}\n */\nfunction returnHiddenElement(element) {\n    // We look if we find a hidden parent. If not, we load right away.\n    while (element !== null) {\n        if (!isHidden(element)) {\n            element = element.parentElement;\n        } else {\n            return element;\n        }\n    }\n    return null;\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n * @param {int} page\n */\nfunction replaceSortColumnLinks(idstring, encodedtable, frag, page) {\n\n    var arrayOfItems = frag.querySelectorAll(\"th.header a\");\n\n    arrayOfItems.forEach(item => {\n        var sortid = item.getAttribute('data-sortby');\n        var sortorder = item.getAttribute('data-sortorder');\n        var thide = item.getAttribute('data-action') == 'hide' ? item.getAttribute('data-column') : null;\n        var tshow = item.getAttribute('data-action') == 'show' ? item.getAttribute('data-column') : null;\n\n        item.setAttribute('href', '#');\n        item.addEventListener('click', () => {\n            callLoadData(idstring, encodedtable, page, sortid, thide, tshow, sortorder);\n        });\n    });\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n * @param {int} page\n */\nfunction replaceResetTableLink(idstring, encodedtable, frag, page) {\n    var arrayOfItems = frag.querySelectorAll(\"div.resettable\");\n\n    if (!arrayOfItems || arrayOfItems.length == 0) {\n        return;\n    }\n    arrayOfItems.forEach(item => {\n        var classofelement = item.getAttribute('class');\n        if (classofelement.indexOf('resettable') >= 0) {\n            let listOfChildren = item.querySelectorAll('a');\n            listOfChildren.forEach(subitem => {\n                subitem.setAttribute('href', '#');\n                subitem.addEventListener('click', () => {\n                    callLoadData(idstring, encodedtable, page, null, null, null, null, 1);\n                });\n            });\n        }\n    });\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n */\nfunction replacePaginationLinks(idstring, encodedtable, frag) {\n    var arrayOfPageItems = frag.querySelectorAll(\".page-item\");\n\n    if (!arrayOfPageItems || arrayOfPageItems.length == 0) {\n        return;\n    }\n    arrayOfPageItems.forEach(item => {\n\n        let pageNumber = item.dataset.pagenumber;\n\n        if (pageNumber) {\n            --pageNumber;\n            item.addEventListener('click', () => {\n                callLoadData(idstring, encodedtable, pageNumber);\n            });\n        }\n    });\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n */\nfunction replaceDownloadLink(idstring, encodedtable, frag) {\n\n    var arrayOfItems = frag.querySelectorAll(\"form\");\n\n    arrayOfItems.forEach(item => {\n        if (item.tagName == 'FORM') {\n            item.setAttribute('method', 'POST');\n            let newnode = document.createElement('input');\n            newnode.setAttribute('type', 'hidden');\n            newnode.setAttribute('name', 'encodedtable');\n            newnode.setAttribute('value', encodedtable);\n            item.appendChild(newnode);\n        }\n    });\n}\n\n/**\n *\n * @param {*} idstring\n * @param {*} encodedtable\n * @param {*} frag\n * @param {*} page\n */\n function replaceLinksInFrag(idstring, encodedtable, frag, page = null) {\n\n    if (!page) {\n        const activepage = frag.querySelector('li.page-item active');\n        if (activepage) {\n            page = activepage.getAttribute('data-page-number');\n        }\n    }\n\n    replaceDownloadLink(idstring, encodedtable, frag);\n    replaceResetTableLink(idstring, encodedtable, frag, page);\n    replacePaginationLinks(idstring, encodedtable, frag);\n    replaceSortColumnLinks(idstring, encodedtable, frag, page);\n}\n"],"names":["element","console","log","parentelement","rowid","classList","contains","dataset","id","parentElement","idstring","getAttribute","encodedtable","wbTableReload","loadings","scrollpages","tablejss","getScrollParent","node","scrollHeight","clientHeight","parentNode","idstringplusa","substring","filterobjects","filterobject","length","JSON","parse","stringify","replacerow","searchstring","sort","callLoadData","hasOwnProperty","callback","identifier","document","querySelector","spinner","isHidden","replaceLinksInFrag","selector","addScrollFunctionality","addReloadFunctionality","observer","MutationObserver","disconnect","hiddenElement","returnHiddenElement","observe","attributes","respondToVisibility","el","style","window","getComputedStyle","display","visibility","page","tsort","thide","tshow","tdir","treset","searchtext","table","getElementById","remove","add","call","methodname","args","done","res","jsonobject","content","rendertemplate","template","container","componentscontainer","rowtemplate","promises","rows","map","row","renderForPromise","then","_ref","html","js","replaceNode","appendNodeContents","catch","e","promise","Templates","_ref2","push","Promise","all","setTimeout","frag","_ref3","firstChild","removeChild","lastChild","parent","ex","addNotification","message","type","fail","err","createElement","textnode","createTextNode","appendChild","scrollinitialized","addEventListener","elementtop","getBoundingClientRect","top","elementheight","height","screenheight","body","rowelements","querySelectorAll","forEach","item","innerHTML","trim","replaceSortColumnLinks","sortid","sortorder","setAttribute","replaceResetTableLink","arrayOfItems","indexOf","subitem","replacePaginationLinks","arrayOfPageItems","pageNumber","pagenumber","replaceDownloadLink","tagName","newnode","activepage"],"mappings":"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"}