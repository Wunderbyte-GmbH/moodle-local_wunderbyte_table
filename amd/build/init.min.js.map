{"version":3,"file":"init.min.js","sources":["../src/init.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    local_wunderbyte_table\n * @copyright Wunderbyte GmbH <info@wunderbyte.at>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\n\nimport {initializeCheckboxes, getFilterOjects} from 'local_wunderbyte_table/filter';\nimport {initializeSearch, getSearchInput} from 'local_wunderbyte_table/search';\nimport {initializeSort, getSortSelection} from 'local_wunderbyte_table/sort';\nimport {initializeReload} from 'local_wunderbyte_table/reload';\nimport {initializeActionButton} from 'local_wunderbyte_table/actionbutton';\n\n// All these variables will be objects with the idstringso their tables as identifiers.\nvar loadings = {};\nexport var queries = {};\nvar scrollpages = {};\nvar tablejss = {};\nvar scrollingelement = {};\n\n/**\n * Gets called from mustache template.\n * @param {string} idstring\n * @param {string} encodedtable\n */\nexport const init = (idstring, encodedtable) => {\n\n    if (!queries[idstring]) {\n        checkInTable(idstring, encodedtable);\n    }\n\n    if (idstring && encodedtable) {\n\n        if (!scrollpages.hasOwnProperty(idstring)) {\n\n            if (infinitescrollEnabled(idstring)) {\n                scrollpages[idstring] = 0;\n            } else {\n                scrollpages[idstring] = -1;\n            }\n\n        }\n\n        respondToVisibility(idstring, encodedtable, callLoadData);\n    }\n};\n\n/**\n * Toggle aside block with filters.\n * @param {string} idstring\n */\nconst initToggleAside = (idstring) => {\n    const togglebutton = document.querySelector('#asidecollapse_' + idstring);\n\n    if (togglebutton) {\n        togglebutton.addEventListener('click', () => {\n            const aside = document.querySelector('.wunderbyte_table_container_' + idstring + ' aside');\n            aside.classList.toggle('inactive');\n            const wbtable = document.querySelector('.wunderbyte_table_container_' + idstring);\n            wbtable.classList.toggle('inactivefilter');\n        });\n    }\n\n};\n\n/**\n * React on visibility change.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {function} callback\n */\nfunction respondToVisibility(idstring, encodedtable, callback) {\n\n    const identifier = 'a' + idstring;\n    let element = document.querySelector('#' + identifier);\n\n    // If we find the table element AND if it has the encoded table set, we abort this.\n    // Hereby we avoid to run JS multiple times.\n    if (element && !element.dataset.encodedtable) {\n        element.dataset.encodedtable = encodedtable;\n    } else {\n\n        // We abort everything else, but we run again the components initialization.\n        // important, as parts of the table might have been reloaded.\n        initializeComponents(idstring, encodedtable);\n        return;\n    }\n\n    // We only make this callback during init if there is the spinner running.\n    // We don't want to run all of this if we don't use lazyloading.\n    let spinner = document.querySelector(\"#\" + identifier + 'spinner');\n\n    if ((spinner !== null) && !isHidden(spinner)) {\n\n        var observer = new MutationObserver(function() {\n            if (!isHidden(element)) {\n                this.disconnect();\n\n                callback(idstring, encodedtable);\n            }\n        });\n\n        const hiddenElement = returnHiddenElement(element);\n\n        if (hiddenElement !== null) {\n\n            observer.observe(hiddenElement, {attributes: true});\n        } else {\n            callback(idstring, encodedtable);\n        }\n\n    } else {\n\n        // This is what we do when we didn't lazyload.\n        replaceLinksInFrag(idstring, encodedtable, element, null);\n\n        initializeComponents(idstring, encodedtable);\n\n        // Check to see if scrolling near bottom of page; load more photos\n        // This shoiuld only be added once.\n\n        // As this can only be here once per table, we mark the table.\n        addScrollFunctionality(idstring, encodedtable, element);\n        initToggleAside(idstring);\n\n    }\n}\n\n/**\n * Return the next scrollable element.\n * @param {*} node\n * @returns {*} node\n */\nfunction getScrollParent(node) {\n    if (node === null) {\n        return null;\n    }\n\n    if (node.scrollHeight > node.clientHeight) {\n        return node;\n    } else {\n        return getScrollParent(node.parentNode);\n    }\n}\n\n/**\n * Function to check visibility of element.\n * @param {*} el\n * @returns {boolean}\n */\nexport const isHidden = (el) => {\n    var style = window.getComputedStyle(el);\n    return ((style.display === 'none') || (style.visibility === 'hidden'));\n};\n\n/**\n * Reloads the rendered table and sets it to the div with the right identifier.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {null|int} page\n * @param {null|string} tsort\n * @param {null|string} thide\n * @param {null|string} tshow\n * @param {null|int} tdir\n * @param {null|int} treset\n * @param {null|string} filterobjects\n * @param {null|string} searchtext\n * @param {null|bool} replacerow\n */\nexport const callLoadData = (\n    idstring,\n    encodedtable,\n    page = null,\n    tsort = null,\n    thide = null,\n    tshow = null,\n    tdir = null,\n    treset = null,\n    filterobjects = null,\n    searchtext = null,\n    replacerow = false) => {\n\n    if (loadings[idstring] && !replacerow) {\n        return;\n    }\n\n    // We reset scrollpage with 0 when we come from the filter.\n    if (page !== null) {\n\n        if (infinitescrollEnabled(idstring)) {\n            scrollpages[idstring] = page;\n        } else {\n            scrollpages[idstring] = -1;\n        }\n    }\n\n    // We always have to see if we need to apply a filter. Reload might come from scroll, but filter has to be applied nevertheless.\n    if (filterobjects === null) {\n        filterobjects = getFilterOjects(idstring);\n    }\n    // We always have to see if we need to apply a serachtextfilter.\n    if (searchtext === null) {\n        searchtext = getSearchInput(idstring);\n    }\n    // We always have to see if we need to apply a sortorder.\n    if (tsort === null) {\n        tsort = getSortSelection(idstring);\n    }\n\n    let table = document.getElementById('a' + idstring);\n\n    // This is now the individual spinner from the wunderbyte table template.\n    let spinner = document.querySelector('#a' + idstring + 'spinner .spinner-border');\n\n    // If we replace the whole table, we show the spinner. If we only add rows in infinite scroll, we don't.\n    if (scrollpages[idstring] == 0\n        && !replacerow) {\n        if (spinner) {\n            spinner.classList.remove('hidden');\n        }\n    }\n\n    // This is used to store information for reload etc.\n    checkInTable(\n        idstring,\n        encodedtable,\n        page,\n        tsort,\n        thide,\n        tshow,\n        tdir,\n        treset,\n        filterobjects,\n        searchtext,\n        replacerow\n    );\n\n    loadings[idstring] = true;\n\n    Ajax.call([{\n        methodname: \"local_wunderbyte_table_load_data\",\n        args: {\n            'encodedtable': encodedtable,\n            'page': page,\n            'tsort': tsort,\n            'thide': thide,\n            'tshow': tshow,\n            'tdir': tdir,\n            'treset': treset,\n            'filterobjects': filterobjects,\n            'searchtext': searchtext\n        },\n        done: function(res) {\n\n            let jsonobject = JSON.parse(res.content);\n            let rendertemplate = res.template;\n\n            // We can always expect a wunderbyte table container at this point.\n            // The container will hold wunderbyteTableClass, wunderbyteTableFilter, wunderbyteTableSearch classes.\n            let container = document.querySelector(\".wunderbyte_table_container_\" + idstring);\n            const componentscontainer = container.querySelector(\".wunderbyte_table_components\");\n\n            // If we only increase the scrollpage, we don't need to render everything again.\n            if (replacerow\n                || (scrollpages[idstring] > 0)) {\n\n                // Also, we want to use the table instead of the container template.\n                const rowtemplate = rendertemplate + '_row';\n\n                if (!jsonobject.table.hasOwnProperty('rows')) {\n                    // We set the scrollpage to -1 which means that we don't reload anymore.\n                    scrollpages[idstring] = -1;\n                    loadings[idstring] = false;\n                    return;\n                }\n                let rows = jsonobject.table.rows;\n\n                // We create an array of promises where every line is rendered individually.\n                const promises = rows.map(row => {\n                    Templates.renderForPromise(rowtemplate, row).then(({html, js}) => {\n\n                        if (replacerow) {\n\n                            // We need the id.\n                            const filterobject = JSON.parse(filterobjects);\n                            const rowid = filterobject.id;\n\n                            Templates.replaceNode(\"#a\" + idstring\n                                + \" .rows-container tr[data-id='\" + rowid + \"']\", html, js);\n                        } else {\n                            // Here we add the rendered content to the table div.\n                            Templates.appendNodeContents('#a' + idstring + \" .rows-container\", html, js);\n                        }\n\n                        return true;\n                    }).catch(e => {\n                        // eslint-disable-next-line no-console\n                        console.log(e);\n                    });\n                    return true;\n                });\n\n\n                if (!tablejss.hasOwnProperty(idstring)) {\n\n                    // eslint-disable-next-line no-unused-vars\n                    const promise = returnPromiseToSaveJS(rendertemplate, jsonobject, idstring);\n\n                    promises.push(promise);\n                }\n\n                // Once all the promises are fullfilled, we set loading to false.\n                Promise.all(promises).then(() => {\n\n                    setTimeout(() => {\n                        // We only added rows, but they might need some js from the table, so we add the table js again.\n                        Templates.appendNodeContents('#a' + idstring, '', tablejss[idstring]);\n\n                    }, 100);\n\n                    loadings[idstring] = false;\n\n                    return;\n                }).catch(e => {\n                    // eslint-disable-next-line no-console\n                    console.log(e);\n                });\n\n                return;\n\n            }\n\n            if (!componentscontainer) {\n                // If the componentscontainer is not yet rendered, we render the container. else, only the table.\n                rendertemplate = rendertemplate + '_container';\n            }\n\n            let frag = container.querySelector(\".wunderbyteTableClass\");\n\n            // We add the sortclass, if necessary.\n            if (tsort\n                && 'table' in jsonobject\n                && 'header' in jsonobject.table\n                && 'headers' in jsonobject.table.header) {\n\n                jsonobject.table.header.headers.forEach(item => {\n                    if (item.key == tsort) {\n\n                        if (tdir == 4) {\n                            item.sortclass = 'desc';\n                        } else {\n                            item.sortclass = 'asc';\n                        }\n                    } else {\n                        delete item.sortclass;\n                    }\n                });\n            }\n\n            // If we called a sorting and the result is an empty array, we don't need to render.\n            let rows = jsonobject.table.rows;\n            if (tsort && (!rows || rows.length < 1)) {\n\n                if (spinner) {\n                    spinner.classList.add('hidden');\n                }\n                if (table) {\n                    table.classList.remove('hidden');\n                }\n\n                loadings[idstring] = false;\n\n            } else {\n                // We render the html with the right template.\n                Templates.renderForPromise(rendertemplate, jsonobject).then(({html, js}) => {\n\n                    if (componentscontainer) {\n                        // Now we clean the existing table.\n                        while (frag.firstChild) {\n                            frag.removeChild(frag.lastChild);\n                        }\n\n                        // Here we add the rendered content to the table div.\n                        Templates.appendNodeContents('#a' + idstring, html, js);\n                    } else {\n                        // Here we try to render the whole.hro\n                        const parent = container.parentElement;\n                        container.remove();\n                        Templates.appendNodeContents(parent, html, js);\n\n                        container = document.querySelector(\".wunderbyte_table_container_\" + idstring);\n                    }\n\n                    replaceLinksInFrag(idstring, encodedtable, container, page);\n\n                    // When everything is done, we loaded fine.\n                    loadings[idstring] = false;\n\n                    if (spinner) {\n                        spinner.classList.add('hidden');\n                    }\n                    if (table) {\n                        table.classList.remove('hidden');\n                    }\n\n                    // Make sure all elements are working.\n                    initializeComponents(idstring, encodedtable);\n\n                    const element = container.querySelector('#a' + idstring);\n\n                    // This is the place where we are after lazyloading. We check if we need to reinitialize scrolllistener:\n                    addScrollFunctionality(idstring, encodedtable, element);\n\n                    return true;\n                }).catch(ex => {\n                    loadings[idstring] = false;\n                    Notification.addNotification({\n                        message: 'failed rendering ' + ex,\n                        type: \"danger\"\n                    });\n                });\n            }\n\n        },\n        fail: function(err) {\n            // If we have an error, resetting the table might be enough. we do that.\n            // To avoid a loop, we only do this in special cases.\n            if ((treset != 1)) {\n                callLoadData(idstring, encodedtable, page, null, null, null, null, 1);\n            } else {\n                let node = document.createElement('DIV');\n                let textnode = document.createTextNode(err.message);\n                node.appendChild(textnode);\n                table.appendChild(node);\n                spinner.classList.add('hidden');\n                table.classList.remove('hidden');\n            }\n        }\n    }]);\n};\n\n/**\n * Add the scroll functionality to the right table.\n * @param {*} idstring\n * @param {*} encodedtable\n * @param {*} element\n * @returns {void}\n */\nfunction addScrollFunctionality(idstring, encodedtable, element) {\n\n    // First we check if scroll functioanlity is enabled.\n    if (!infinitescrollEnabled(idstring)) {\n        return;\n    }\n\n    if (element.dataset.scrollinitialized) {\n        return;\n    }\n\n    element.dataset.scrollinitialized = true;\n\n    const scrollableelement = getScrollParent(element);\n\n    if (!scrollableelement) {\n        return;\n    }\n\n    scrollableelement.addEventListener('scroll', () => {\n\n        if (!scrollingelement.hasOwnProperty(idstring)) {\n            scrollingelement[idstring] = 'scrollElement';\n        } else {\n            if (scrollingelement[idstring] === 'scrollElement') {\n                scrollListener(element, idstring, encodedtable);\n            }\n        }\n    });\n\n    // It's not easy to decide which is the right, so we have to add both.\n    window.addEventListener('scroll', () => {\n\n        if (!scrollingelement.hasOwnProperty(idstring)) {\n            scrollingelement[idstring] = 'window';\n        } else {\n            if (scrollingelement[idstring] === 'window') {\n                scrollListener(element, idstring, encodedtable);\n            }\n        }\n    });\n\n}\n\n/**\n * To be called in the scroll listener.\n * @param {node} element\n * @param {string} idstring\n * @param {string} encodedtable\n * @returns {void}\n */\nfunction scrollListener(element, idstring, encodedtable) {\n\n\n    // We only want to scroll, if the element is visible.\n    // So, if we find a hidden element in the parent, we don't scroll.\n    if (returnHiddenElement(element)) {\n        return;\n    }\n\n    const elementtop = element.getBoundingClientRect().top;\n    const elementheight = element.getBoundingClientRect().height;\n    const screenheight = document.body.scrollHeight;\n\n    if (!loadings[idstring] && scrollpages[idstring] >= 0) {\n        if (elementtop + elementheight - screenheight < 0) {\n            scrollpages[idstring] = scrollpages[idstring] + 1;\n            callLoadData(idstring,\n                encodedtable,\n                scrollpages[idstring],\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null);\n        }\n    }\n}\n\n/**\n * If the element or one of its parents is hidden, we return it. the hiddenn element.\n * Else we return null.\n * @param {node} element\n * @returns {null|node}\n */\nfunction returnHiddenElement(element) {\n    // We look if we find a hidden parent. If not, we load right away.\n    while (element !== null) {\n        if (!isHidden(element)) {\n            element = element.parentElement;\n        } else {\n            return element;\n        }\n    }\n    return null;\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n * @param {int} page\n */\nfunction replaceSortColumnLinks(idstring, encodedtable, frag, page) {\n\n    var arrayOfItems = frag.querySelectorAll(\"th.header a\");\n\n    arrayOfItems.forEach(item => {\n        var sortid = item.getAttribute('data-sortby');\n        var sortorder = item.getAttribute('data-sortorder');\n        var thide = item.getAttribute('data-action') == 'hide' ? item.getAttribute('data-column') : null;\n        var tshow = item.getAttribute('data-action') == 'show' ? item.getAttribute('data-column') : null;\n\n        item.setAttribute('href', '#');\n        item.addEventListener('click', () => {\n            callLoadData(idstring, encodedtable, page, sortid, thide, tshow, sortorder);\n        });\n    });\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n * @param {int} page\n */\nfunction replaceResetTableLink(idstring, encodedtable, frag, page) {\n    var arrayOfItems = frag.querySelectorAll(\"div.resettable\");\n\n    if (!arrayOfItems || arrayOfItems.length == 0) {\n        return;\n    }\n    arrayOfItems.forEach(item => {\n        var classofelement = item.getAttribute('class');\n        if (classofelement.indexOf('resettable') >= 0) {\n            let listOfChildren = item.querySelectorAll('a');\n            listOfChildren.forEach(subitem => {\n                subitem.setAttribute('href', '#');\n                subitem.addEventListener('click', () => {\n                    callLoadData(idstring, encodedtable, page, null, null, null, null, 1);\n                });\n            });\n        }\n    });\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n */\nfunction replacePaginationLinks(idstring, encodedtable, frag) {\n    var arrayOfPageItems = frag.querySelectorAll(\".page-item\");\n\n    if (!arrayOfPageItems || arrayOfPageItems.length == 0) {\n        return;\n    }\n    arrayOfPageItems.forEach(item => {\n\n        let pageNumber = item.dataset.pagenumber;\n\n        if (pageNumber) {\n            --pageNumber;\n            item.addEventListener('click', () => {\n                callLoadData(idstring, encodedtable, pageNumber);\n            });\n        }\n    });\n}\n\n/**\n * The rendered table has links we can't use. We replace them with eventlisteners and use the callLoadData function.\n * @param {string} idstring\n * @param {string} encodedtable\n * @param {DocumentFragment} frag\n */\nfunction replaceDownloadLink(idstring, encodedtable, frag) {\n\n    var arrayOfItems = frag.querySelectorAll(\"form\");\n\n    arrayOfItems.forEach(item => {\n        if (item.tagName == 'FORM') {\n            item.setAttribute('method', 'POST');\n            let newnode = document.createElement('input');\n            newnode.setAttribute('type', 'hidden');\n            newnode.setAttribute('name', 'encodedtable');\n            newnode.setAttribute('value', encodedtable);\n            item.appendChild(newnode);\n        }\n    });\n}\n\n/**\n *\n * @param {*} idstring\n * @param {*} encodedtable\n * @param {*} frag\n * @param {*} page\n */\nfunction replaceLinksInFrag(idstring, encodedtable, frag, page = null) {\n\n    if (!page) {\n        const activepage = frag.querySelector('li.page-item active');\n        if (activepage) {\n            page = activepage.getAttribute('data-page-number');\n        }\n    }\n\n    replaceDownloadLink(idstring, encodedtable, frag);\n    replaceResetTableLink(idstring, encodedtable, frag, page);\n    replacePaginationLinks(idstring, encodedtable, frag);\n    replaceSortColumnLinks(idstring, encodedtable, frag, page);\n}\n\n/**\n * Function to check if the talbe in question has infinitescroll enabled.\n * @param {string} idstring\n * @returns {bool}\n */\nfunction infinitescrollEnabled(idstring) {\n    // If we don't find the infinitescrollelement, we don#t add the listener.\n    const selector = \".wunderbyte_table_container_\" + idstring;\n    if (document.querySelector(selector + ' div.infinitescroll_enabled')) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Initialize all the JS we need.\n * @param {string} idstring\n * @param {string} encodedtable\n */\nfunction initializeComponents(idstring, encodedtable) {\n    const selector = \".wunderbyte_table_container_\" + idstring;\n    initializeCheckboxes(selector, idstring, encodedtable);\n    initializeSearch(selector, idstring, encodedtable);\n    initializeSort(selector, idstring, encodedtable);\n    initializeReload(selector, idstring, encodedtable);\n    initializeActionButton(selector, idstring, encodedtable);\n}\n\n/**\n * Function to return promise.\n * @param {*} rendertemplate\n * @param {*} jsonobject\n * @param {*} idstring\n * @returns {Promise}\n */\nfunction returnPromiseToSaveJS(rendertemplate, jsonobject, idstring) {\n    // eslint-disable-next-line no-unused-vars\n    return Templates.renderForPromise(rendertemplate, jsonobject).then(({html, js}) => {\n\n        tablejss[idstring] = js;\n\n        return true;\n    }).catch(e => {\n        // eslint-disable-next-line no-console\n        console.log(e);\n    });\n}\n\n/**\n * Function to save queries. Has some logic which helps us to achieve the desired result.\n * @param {*} idstring\n * @param {*} encodedtable\n * @param {*} page\n * @param {*} tsort\n * @param {*} thide\n * @param {*} tshow\n * @param {*} tdir\n * @param {*} treset\n * @param {*} filterobjects\n * @param {*} searchtext\n * @param {*} replacerow\n */\nfunction checkInTable(\n    idstring,\n    encodedtable,\n    page = null,\n    tsort = null,\n    thide = null,\n    tshow = null,\n    tdir = null,\n    treset = null,\n    filterobjects = null,\n    searchtext = null,\n    replacerow = false) {\n\n    // We don't want to save any queries that want to replace row.\n    if (replacerow) {\n        return;\n    }\n\n    queries[idstring] = {\n        idstring,\n        encodedtable,\n        page,\n        tsort,\n        thide,\n        tshow,\n        tdir,\n        treset,\n        filterobjects,\n        searchtext,\n        replacerow: false // Replace row is always false.\n    };\n}"],"names":["loadings","queries","scrollpages","tablejss","scrollingelement","idstring","encodedtable","checkInTable","hasOwnProperty","infinitescrollEnabled","callback","identifier","element","document","querySelector","dataset","initializeComponents","spinner","isHidden","replaceLinksInFrag","addScrollFunctionality","togglebutton","addEventListener","classList","toggle","initToggleAside","observer","MutationObserver","disconnect","hiddenElement","returnHiddenElement","observe","attributes","respondToVisibility","callLoadData","getScrollParent","node","scrollHeight","clientHeight","parentNode","el","style","window","getComputedStyle","display","visibility","page","tsort","thide","tshow","tdir","treset","filterobjects","searchtext","replacerow","table","getElementById","remove","call","methodname","args","done","res","jsonobject","JSON","parse","content","rendertemplate","template","container","componentscontainer","rowtemplate","promises","rows","map","row","renderForPromise","then","_ref","html","js","rowid","id","replaceNode","appendNodeContents","catch","e","console","log","promise","returnPromiseToSaveJS","push","Promise","all","setTimeout","frag","header","headers","forEach","item","key","sortclass","length","add","_ref2","firstChild","removeChild","lastChild","parent","parentElement","ex","addNotification","message","type","fail","err","createElement","textnode","createTextNode","appendChild","scrollinitialized","scrollableelement","scrollListener","elementtop","getBoundingClientRect","top","elementheight","height","screenheight","body","replaceSortColumnLinks","querySelectorAll","sortid","getAttribute","sortorder","setAttribute","replaceResetTableLink","arrayOfItems","indexOf","subitem","replacePaginationLinks","arrayOfPageItems","pageNumber","pagenumber","replaceDownloadLink","tagName","newnode","activepage","selector","Templates","_ref3"],"mappings":"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"}